# 计算机网络

会导致，因为，如果--就，所以

[计算机网络 (5) 数据链路层-MAC地址、IP地址及ARP协议MAC地址 作用 两台主机之间最简单的通信方式是使用信道 - 掘金 (juejin.cn)](https://juejin.cn/post/7135362984125628447?share_token=9f663189-af83-4fb5-a935-d628417ed8b0)

[通俗易懂的TCP，SSL以及HTTPS的连接建立过程详解_tcp ssl-CSDN博客](https://blog.csdn.net/yxg520s/article/details/122004032)

[TCP连接与HTTP请求 - 和风细羽 - 博客园 (cnblogs.com)](https://www.cnblogs.com/dins/p/tcp-http.html)

[TLS/SSL 工作原理及握手过程详解_tls原理图解-CSDN博客](https://blog.csdn.net/qq_38289815/article/details/107591115)

[TCP的三次握手各字段(ack,seq,ACK,SYN)是什么意思？_三次握手ack和ack-CSDN博客](https://blog.csdn.net/weixin_48684274/article/details/108263608)

[面试题：聊聊TCP的粘包、拆包以及解决方案 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/356225028#:~:text=什么是粘包？ 在学习粘包之前，先纠正一下读音，很多视频教程中将“粘”读作“nián”。 经过调研，个人更倾向于读“zhān,bāo”。 如果在百度百科上搜索“粘包”，对应的读音便是“zhān bāo”，语义解释为：网络技术术语。 指TCP协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。)

[TCP——SYN、ACK、FIN、RST、PSH、URG详解_syn urg-CSDN博客](https://blog.csdn.net/dyzhen/article/details/45065319)

[TCP协议之RST与FIN_tcp fin-CSDN博客](https://blog.csdn.net/yangguosb/article/details/79224872?ops_request_misc=%7B%22request%5Fid%22%3A%2231352B46-72B9-4276-B0DB-7F084656C7FA%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=31352B46-72B9-4276-B0DB-7F084656C7FA&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79224872-null-null.142^v100^control&utm_term=RST和FIN&spm=1018.2226.3001.4187)

[NAT(地址转换技术)详解_nat技术-CSDN博客](https://blog.csdn.net/gui951753/article/details/79593307)

# 基础篇

## 2.1  TCP/IP网络模型有哪几层

网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

### 应用层

- 应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。
- 而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态

### 传输层

- 应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。
- 应用层数据传输较大，直接传输不好控制，因此当传输层数据包超过mss（TCP最大报文段长度）进行分块。
- 端口是用于区分不同的应用的编号

### 网络层

- 而实际的传输功能就交给下一层，也就是网络层

- IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。

- IP地址

  - 作用1：寻址能力，需要有区分设备的编号

    - 网络号：标识属于哪个子网
    - 主机号：标识同一子网下的不同主机
    - 子网掩码和IP地址进行按位与获得网络号
      子网掩码取反和IP地址进行按位与获得主机

  - 作用2：路由

    路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。

### 网络接口层

- 网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。

  - MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。

- 网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。

  什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。
  
  

## 2.2 键入网址到网址显示，期间发生了什么

### HTTP

1. 解析URL,确定Web服务器和文件名
   1. 当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 /index.html 或者 /default.html 这些文件，这样就不会发生混乱了。
2. 生产http请求信息

### DNS

- 通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 `Web` 服务器。

- **DNS保存了Web服务器域名与IP的对应关系**

- 域名的层次结构类似一个树状结构

  - 根DNS服务器（.）
  - 顶级域DNS服务器（.com）
  - 权威DNS服务器(server.com)

- 域名解析的工作流程

  - 客户端发起DNS请求

    浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。

  - 本地DNS查找缓存

  - 本地DNS依次向根DNS服务器、顶级域DNS服务器查询、权威DNS服务器查询

  - 本地DNS将结果返回给客户端

### 协议栈

- 通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。
- 应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。
  - 协议栈的**上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议**
  - 协议栈的**下面一半是用 IP 协议**控制网络包收发操作
    - 此外 IP 中还包括 ICMP 协议和 ARP 协议。
      - **ICMP** 用于告知网络包传送过程中产生的错误以及各种控制信息。
      - **ARP** 用**于根据 IP 地址查询相应的以太网 MAC 地址。**
- IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作。

#### TCP

1. TCP包头格式

   <img src="D:\2024\Notes\Typora\八股\计算机网络.assets\image-20241006100619467.png" alt="image-20241006100619467" style="zoom:50%;" />

   1. 源端口号+目标端口号
   2. 包的序号（解决包的乱序问题）
   3. 确认号（解决丢包问题：确认发出对方是否收到，没收到重发）
   4. 状态位
      1. SYN 发起一个链接
      2. ACK 回复
      3. RST 重新连接
      4. FIN 结束连接
   5. 窗口大小（进行流量控制、拥塞控制，通信双方各声明一个窗口（缓存大小））

2. TCP三次握手建立连接：保证双方都有发送和接收的能力

   <img src="D:\2024\Notes\Typora\八股\计算机网络.assets\image-20241006101032739.png" alt="image-20241006101032739" style="zoom:50%;" />

   1. 客户端和服务端都处于CLOSE状态
   2. 服务端主动监听某个端口，处于LISTEN状态
   3. 客户端主动发起连接SYN，然后处于SYN_SENT状态
   4. 服务端收到发起的连接，返回SYN，并且ACK客户端发出的SYN，处于SYN_RCVD状态
   5. 客户端收到服务端的SYN和ACK，发送对于SYN确认的ACK，然后处于ESTABLISHED状态
   6. 服务端收到ACK之后，也处于ESTABLISHED状态

   查看TCP连接状态 netstat - napt命令

3. TCP分割数据

   MTU：一个网络包的最大长度 1500字节，包括IP头部+TCP头部+数据

   MSS：数据的最大长度

   如果HTTP请求消息长度超过MSS，TCP对消息进行分割

4. TCP报文生成

   TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 80， HTTPS 默认端口号是 443）。

#### IP

1. TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委**托 IP 模块将数据封装成网络包发送给通信对象。**

2. IP报头格式

   <img src="D:\2024\Notes\Typora\八股\计算机网络.assets\14.jpg" alt="IP 包头格式" style="zoom: 33%;" />

   1. 源地址IP+目标地址IP
   2. 协议(TCP)

3. 假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？

   将IP地址和子网掩码进行与运算，然后在路由表中挨个匹配。

#### MAC

1. 生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。
2. 一般在 TCP/IP 通信里，MAC 包头的协议类型只使用：
   0800 ： IP 协议
   0806 ： ARP 协议
3. 接收方的mac地址如何确认：根据IP找mac
   1. ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。
   2. 把本次查询结果放到一块叫做 ARP 缓存的内存空间留着以后用

### 网卡

- 网卡负责将数字信号转为电信号
- 控制网卡需要靠网卡驱动程序
- 在网络包开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。

### 交换机

- 交换机的设计是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为二层网络设备。
  - **交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。**
- 将电信号转为数字信号、校验错误
- 计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，**交换机的端口不核对接收方 MAC 地址**，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有 MAC 地址。
- 将包存入缓冲区后，需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。
  - 交换机的 MAC 地址表主要包含两个信息：
    一个是**设备的 MAC 地址，**
    另一个是**该设备连接在交换机的哪个端口上。**
  - 当 MAC 地址表找不到指定的 MAC 地址会怎么样？
    - 只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。
    - 只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。
  - 如果接收方 MAC 地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。
    以下两个属于广播地址：
    MAC 地址中的 FF:FF:FF:FF:FF:FF
    IP 地址中的 255.255.255.255

### 路由器

1. 网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。

   1. 因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
   2. 而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。

2. 路由器的端口**具有 MAC 地址**，因此它就能够成为以太网的发送方和接收方；
   同时还具**有 IP 地址**，从这个意义上来说，它和计算机的网卡是一样的。
   当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，由相应的端口作为发送方将以太网包发出去。

3. 路由器的发送

   1. 首先根据路由表的网关列判断对方的地址
      1. 网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。
      2. 网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。
   2. 接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。

   

**在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输**。

## 2.3 Linux系统是如何收发网络包的？

### 网络模型

OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。

1. 应用层，负责给应用程序提供统一的接口；
2. 表示层，负责把数据转换成兼容另一个系统能识别的格式；
3. 会话层，负责建立、管理和终止表示层实体之间的通信会话；
4. 传输层，负责端到端的数据传输；
5. 网络层，负责数据的路由、转发、分片；
6. 数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；
7. 物理层，负责在物理网络中传输数据帧；

TCP/IP 网络模型共有 4 层，分别是应用层、传输层、网络层和网络接口层，每一层负责的职能如下：

1. 应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;
2. 传输层，负责端到端的通信，比如 TCP、UDP 等；
3. 网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；
4. 网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；

**我们常说的七层和四层负载均衡，是用 OSI 网络模型来描述的，七层对应的是应用层，四层对应的是传输层。**

### Linux网络协议栈

1. 应用程序需要通过系统调用，来跟 Socket 层进行数据交互；
2. Socket 层的下面就是传输层、网络层和网络接口层；
3. 最下面的一层，则是网卡驱动程序和硬件网卡设备；

当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去

# HTTP篇

## 3.1 HTTP常见面试题

### HTTP基本概念

#### 1. 什么是HTTP

HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。

HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范

#### 2. HTTP常见的状态码有哪些

1. 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
2. 2xx 类状态码表示**服务器成功处理了客户端的请求**，也是我们最愿意看到的状态。
   1. 「200 OK」是最常见的**成功状态码**，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
   2. 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但**响应头没有 body 数据。**
   3. 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应**返回的 body 数据并不是资源的全部，而是其中的一部分**，也是服务器处理成功的状态。
3. 3xx 类状态**码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。**
   1. 「301 Moved Permanently」表示**永久重定向**，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
   2. 「302 Found」表示**临时重定向**，说明请求的资源还在，**但暂时需要用另一个 URL 来访问。**
      301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
   3. 「304 Not Modified」不**具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，**也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
4. 4xx 类状态码表示**客户端发送的报文有误，服务器无法处理，也**就是错误码的含义。
   1. 「400 Bad Request」表示客户端**请求的报文有错误**，但只是个笼统的错误。
   2. 「403 Forbidden」表示**服务器禁止访问资源**，并不是客户端的请求出错。
   3. 「404 Not Found」表示**请求的资源在服务器上不存在或未找到**，所以无法提供给客户端。
5. 5xx 类状态码表示**客户端请求报文正确，但是服务器处理时内部发生了错误**，属于服务器端的错误码。
   1. 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
   2. 「501 Not Implemented」表示客户端请求的**功能还不支持**，类似“即将开业，敬请期待”的意思。
   3. 「502 Bad Gateway」通常是服务器**作为网关或代理时返回的错误码**，表示服务器自身工作正常，访问后端服务器发生了错误。
   4. 「503 Service Unavailable」表示服**务器当前很忙，暂时无法响应客户端，类**似“网络服务正忙，请稍后重试”的意思

#### 3. HTTP常见字段有哪些？

1. Host字段

   客户端发送请求时，用来指定服务器的域名。

2. Content-Length字段

   服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。

   HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。

3. Connection字段

   Connection 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。

4. Content-Type字段

   Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

5. Content-Encoding字段

   Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

### GET POST

#### 1. GET和Post有什么区别

- GET 的语义是**从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 **URL 中，URL 规定只能支持 ASCII**，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 **URL 的长度有限制**（HTTP协议本身对 URL长度并没有做任何规定）
- POST 的语义是**根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是**写在报文 body 中，body 中的数据可以是任意格式的数据，**只要客户端与服务端协商好即可，而且浏览器**不会对 body 大小做限制。**

#### 2. GET和POST方法都是安全幂等的吗

所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

- **GET 方法就是安全且幂等的，因为它是「只读」操作，**无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。
- **POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，**且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。

### HTTP缓存技术

#### 1. HTTP缓存有哪些实现方式

对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，避免发送 HTTP 请求的方法就是通过缓存技术。HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存

#### 2. 什么是强制缓存

- 强缓存指的是**只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存**，决定是否使用缓存的主动性在于浏览器这边。
- 强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：
  - Cache-Control， 是一个相对时间；
  - Expires，是一个绝对时间；
    如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires** 
- 实现过程
  - 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
  - 浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；
  - 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control

#### 3. 什么是协商缓存

- 你可能会看到过某些请求的响应码是 304，这个是告诉浏览器可以使用本地缓存的资源，**通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存**
- 协商缓存可以基于两种头部来实现。
  - 请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现，
  - 请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段













### HTTP特性

### HTTP HTTPS

### HTTP/1.1 HTTP/2 HTTP/3





















## 3.2 HTTP/1.1 如何优化

## 3.3 HTTPS RSA握手解析

## 3.4 HTTP ECDHE握手解析

## 3.5HTTPS如何优化

## 3.6 Http2厉害在哪里

## 3.7 HTTP3强势来袭

## 3.8 既然有HTTP协议，为什么还要有RPC

## 3.9 既然有HTTP协议，为什么还要有WebSocket

# TCP篇

## 4.1 TCP三次握手与四次挥手面试题

///todo 网络抓包

## 4.2 TCP重传、滑动窗口、流量控制、拥塞控制

## 4.3 TCP实战抓包分析

///

## 4.4 TCP半连接队列和全连接队列

///

## 4.5 如何优化TCP？

## 4.6 如何理解TCP是面向字节流协议

## 4.7 为什么TCP每次建立连接时，初始化序列号都要不一样呢？

## 4.8 SYN报文什么时候下情况会被丢弃？

## 4.9 已建立连接的TCP，收到SYN会发生什么？

## 4. 10 四次挥手中收到乱序的FIN包会如何处理？

## 4.11 在TIME_WAIT状态的TCP连接，收到SYN以后会发生什么？

## 4.12 TCP连接，一端断电和进程崩溃有什么区别?

## 4.13 拔掉网线后，原本的TCP连接还存在吗？

## 4.14 tcp_tw_reuse为什么是默认关闭的？

## 4.14-2 HTTPS中TLS和TCP能同时握手吗？

## 4.15 TCP keepalive 和 HTTP keep-Alive是一个东西吗

## 4.16 TCP协议有什么缺陷？

## 4.17 如何基于UDP协议实现可靠性传输？

## 4.18 TCP和UDP可以使用同一个端口吗？

## 4.19 服务端没有listen，客户端发起连接建立，会发生什么？

## 4.20 没有accept连接，能建立TCP连接吗

## 4.21 用了TCP协议，数据一定不会丢吗？

## 4.22 TCP四次挥手，可以变成三次吗？

## 4.23 TCP序列号和确认是如何变化的

# IP篇

## 5.1  IP基础知识全家桶

///todo子网掩码如何确定

## 5.2 ping的工作原理

## 5.3 断网了，还能ping通127.0.1吗？