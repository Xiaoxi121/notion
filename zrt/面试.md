# 准备文档

## 自我介绍 

面试官你好，我是来自西安邮电大学计算机科学与技术专业的一名大三学生。

首先我来介绍一下我的大学经历：

在大一期间，我加入了我们学校的兴趣编程小组：软件科技协会，

在加入协会后我相继学习了c语言，数据结构与算法等基础知识，

并参加了一些竞赛，比如数模，蓝桥杯，团体程序设计天梯赛，获得省一、省二和铜牌的成绩

参加了四六级考试，获得了均分620+的成绩。

在进入大二我选择我们协会后台开发方向中的java方向，开始接触javaweb方向的开发，

期间，学习了有如spring，springboot等框架，简单了解了spring cloud框架，

还有如mysql，redis等数据库，学习了rabbitMQ等中间件。

在大二下大三上的时候学习了操作系统，计算机网络，等计算机基础知识。

在学习期间我自己开发了一些小项目，也和同学合作开发了一些项目，

目前感觉自己的开发能力还是很有限，希望到企业中去增强自己的开发能力和项目设计能力。谢谢面试官。

## 专业技能

- **Java**：熟悉Java基础知识、Java并发编程，掌握JUC中常用的工具类，如ConcurrentHashMap等。
- **JVM**：熟悉JVM的垃圾回收机制、类加载机制，了解Java的内存模型。
- **MySQL**：熟练使用 MySQL，熟悉 MySQL 索引、事务、存储引擎、锁机制。
- **Redis**：熟悉Redis常见数据类型，熟悉持久化和过期淘汰策略，掌握缓存穿透、缓存击穿、缓存雪崩。
- **常用框架**：熟练使用Spring、SpringBoot、MyBatis等常用框架，熟悉  IoC 、AOP 原理，了解 Netty、Zookeeper、RabbitMQ等常见组件。
- **计算机网络**：熟悉TCP/IP四层体系分层结构，掌握常见网络协议，如HTTP/HTTPS、TCP等。
- **操作系统**：了解操作系统的进程通信、死锁、内存管理等知识。

### ConcurrentHashMap

ConcurrentHashMap 是 Java 并发包 (java.util.concurrent) 中的一个线程安全的哈希映射实现。它主要用于在多线程环境中提供高性能的并发访问。与传统的 HashMap 或者使用 Collections.synchronizedMap() 包装的 HashMap 相比，ConcurrentHashMap 在并发环境下提供了更好的性能和可伸缩性。

特点

- 线程安全：ConcurrentHashMap 是线程安全的，这意味着多个线程可以安全地并发访问和修改映射，而不需要额外的同步措施。
- 非阻塞设计：在 Java 8 之前的版本中，ConcurrentHashMap 采用了分段锁（Segmented Locking）的策略来实现线程安全。每个桶（Bucket）都有自己的锁，这样当并发写入发生在不同的桶时，就不会互相阻塞。
- 并发性能：由于 ConcurrentHashMap 设计为支持高并发读写操作，因此它在多核处理器环境下表现优异。Java 8 及之后的版本改进了 ConcurrentHashMap 的实现，**采用 CAS（Compare and Swap）加上 synchronized 来实现线程安全，进一步提高了性能。**
- 容量调整：ConcurrentHashMap 支持动态调整容量，可以在运行时根据负载情况自动调整大小。
- 懒惰初始化：默认情况下，ConcurrentHashMap 的初始容量为 16，并且在第一次写入时才创建。
- 迭代安全性：迭代 ConcurrentHashMap 时，可以容忍结构上的修改，即迭代器不会抛出 ConcurrentModificationException 异常，但是迭代结果可能包含已删除的条目或重复的条目

### JVM的垃圾回收机制、类加载机制，了解Java的内存模型。

Java 虚拟机（JVM）是 Java 应用程序运行的基础，它负责管理程序的执行环境，包括但不限于内存管理和类的加载。以下是关于 JVM 的垃圾回收机制、类加载机制以及 Java 内存模型的基本介绍。

#### Java 垃圾回收机制（Garbage Collection）

垃圾回收是 JVM 自动管理内存的一部分，它的主要目的是自动检测并回收不再使用的对象所占用的内存。Java 中的对象存储在堆内存中，当对象不再被任何活动线程的局部变量或其他对象引用时，它就成为了垃圾。

#### 主要特性：
- **自动性**：开发人员无需手动释放内存。
- **透明性**：垃圾回收的具体实现细节对于应用程序来说是透明的。
- **效率**：现代 JVM 实现了多种高效的垃圾回收算法，以减少垃圾回收带来的暂停时间。

#### 常见的垃圾回收算法：
- **标记-清除算法**：首先标记所有需要回收的对象，然后清除这些对象。
- **复制算法**：将内存分为两个相等的部分，每次只使用其中的一部分，垃圾回收时将存活的对象复制到另一部分。
- **标记-压缩算法**：在标记的基础上，将存活的对象向一端移动，然后直接清除掉端边界以外的内存。
- **分代收集算法**：基于对象存活时间的不同将堆分为新生代和老年代，分别使用不同的垃圾回收算法。

#### 类加载机制（Class Loading）

类加载是 JVM 将类的字节码文件加载到内存中，并对其进行校验、准备和解析的过程，最终生成对应的 `java.lang.Class` 对象。

#### 类加载的三个阶段：
1. **加载（Loading）**：查找并读取类的二进制数据，然后将其转化为 Class 对象。
2. **验证（Verification）**：确保类的正确性，包括字节码文件格式的正确性、元数据的完整性等。
3. **准备（Preparation）**：为类的静态变量分配内存并设置默认值。
4. **解析（Resolution）**：将符号引用转换成直接引用。

此外，类加载还有初始化（Initialization）阶段，此时为类的静态变量赋初始值，并执行静态代码块。

#### Java 内存模型（Java Memory Model）

Java 内存模型描述了 Java 程序中各种变量（线程共享变量）的访问规则，以及在并发环境下内存的可见性、有序性和原子性。

#### 主要特性：
- **可见性**：当一个线程修改了一个共享变量的值，其他线程能够立即看到这个修改。
- **有序性**：Java 内存模型中的锁（synchronized 关键字）和其他内存同步工具（如 volatile 关键字）可以保证指令的有序性。
- **原子性**：基本数据类型的赋值操作是原子性的，不能被中断。

#### 内存区域：
- **堆内存（Heap）**：所有对象实例都在这里分配内存。
- **栈内存（Stack）**：存放局部变量、操作数栈、动态链接等信息。
- **方法区（Method Area）**：存储已被虚拟机加载的类信息、常量、静态变量等数据。
- **程序计数器（Program Counter Register）**：指示当前线程所执行的字节码的行号。
- **本地方法栈（Native Method Stack）**：与虚拟机栈作用类似，只不过虚拟机栈执行的是 Java 方法，而本地方法栈执行的是 Native 方法。

这些概念共同构成了 Java 程序的运行时环境，理解它们对于开发高效、可靠的 Java 应用程序至关重要。

## 项目经历

### **基于Netty的RPC框架实现**

- 项目简述：实现分布式场景下本地服务在RPC节点上的注册、发布与远程调用功能。

- 项目技术：**Netty + ZooKeeper + Guava Retry + Protostuff + Kryo + Hessian**

- 项目内容：

1. 自定义通信协议，解决粘包问题；自定义编/解码器和序列化器，实现Protostuff、Kryo、Hessian等多种数据序列化方式。

2. 使用高性能网络框架Netty实现NIO网络通信，消费端复用Channel避免多次连接，提高性能。

3. 使用ZooKeeper作为注册中心和配置中心，在客户端建立缓存，避免频繁访问注册中心；使用Watcher监听节点变化，根据event事件类型动态更新本地缓存。

4. 实现轮询、随机访问、一致性哈希算法等多种负载均衡策略，使客户端请求合理分配到不同的服务实例上。

5. 使用Guava-Retry框架实现对白名单上幂等性服务的超时重试机制，制定重试策略。

6. 服务端实现服务降级：故障降级，故障一定次数通知注册中心下线节点；限流降级，使用令牌桶算法实现接口限流 。

7. 服务端设置熔断器，监测服务调用情况的切换，实现熔断保护；对已下线节点进行定时探测，保证容错性。

1. 粘包问题：在使用Netty的过程中，我们需要解决TCP传输中的粘包问题。为此，我们自定义了消息头来明确标识消息的边界，包括消息长度等信息，这样接收方就可以准确地读取完整的消息。
2. 服务发现与负载均衡：为了确保服务能够动态地发现和均衡负载，我使用了Nacos作为服务注册中心，并实现了几种负载均衡策略，如轮询、随机等。此外，为了保证服务列表的实时性和准确性，我们使用了Nacos的事件监听功能来动态更新服务列表。
3. 熔断与重试机制：为了提高系统的容错能力和可用性，我们实现了熔断器机制，并且只对幂等的服务进行重试。这样做可以避免非幂等操作（如数据库插入）带来的副作用

### **基于SpringBoot的网页版即时通讯系统**

- 项目简述：一个分布式的即时通讯系统，支持好友、群组、私聊、群聊、离线消息拉取、发送文件等功能。

- 项目技术：**SpringBoot + MyBatis-Plus + Netty + MySQL + Redis + RabbitMQ + MinIO**

- 项目内容：

1. 服务器支持集群化部署，每个服务器仅处理自身连接用户的请求，具有良好的横向拓展能力。
2. 通过RabbitMQ的消息队列服务转发消息，进行流量削峰和解耦，并利用Confirm消息确认模式和Ack机制来确保消息的可靠投递。
3. 使用Redis缓存来减少数据库访问频率，记录好友关系、群组成员关系等，提高了系统响应速度和用户体验。
4. 实现用户登录鉴权功能，采用双Token机制确保用户身份的安全验证，提升了用户体验、保证了安全性。
5. 使用WebSocket协议建立了客户端与服务端之间的长连接，保证了消息的实时性，并通过心跳机制维持连接的持久性。
6. 使用基于HashMap实现的前缀树和字符串匹配算法，完成敏感词的实时过滤功能；利用MinIO作为文件存储解决方案，支持图片和其他多媒体内容的上传与管理。

数据库设计与优化：在数据库设计方面，我们需要考虑性能和扩展性。我们使用了MySQL作为主数据库，并通过合理的索引设计和查询优化来提高查询效率。同时，我们也利用Redis进行数据缓存，减少了数据库的压力。

# 9.30 决策数

### 求一个字符串的最长回文子串（要求两种方法动态规划和中心扩展法）

[5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/solutions/255195/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/)

### 程序上线请求打过来未响应分析什么原因

现象：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。
临时解决办法：紧急回滚至上一稳定版本。
分析：使用 MAT (Memory Analyzer Tool)工具分析 dump 文件。
建议：正常情况下，-Xmn参数（控制 Young 区的大小）总是应当小于-Xmx参数（控制堆内存的最大大小），否则就会触发 OOM 错误。
资料：最重要的 JVM 参数总结 - JavaGuide - 2023

当程序上线后请求未响应时，除了**网络、服务器负载、代码错误**等方面的原因外，内存和 JVM 层面的问题也是常见的原因。以下是一些与内存和 JVM 相关的可能原因及其排查方法：

#### 1. 内存泄漏
- **内存泄漏**：程序中存在未释放的对象引用，导致内存持续增长直至耗尽。
- **检查内存泄漏**：使用工具如 VisualVM、MAT（Memory Analyzer Tool）、JProfiler 等来分析内存快照，找出泄漏的对象。

#### 2. 堆内存溢出
- **堆内存溢出（OutOfMemoryError）**：当 Java 堆内存不足时，JVM 会抛出 OutOfMemoryError 异常。
- **检查堆内存使用情况**：使用 JMX 工具或 JVM 参数 `-Xmx` 和 `-Xms` 来调整最大和初始堆内存大小。

#### 3. 永久代（PermGen）或元空间（Metaspace）溢出
- **永久代/元空间溢出**：在 JDK 8 之前，类的信息存储在永久代中，如果类加载过多，可能会导致永久代溢出。JDK 8 及以后版本将类信息移到了元空间，位于本地内存中。
- **检查永久代/元空间使用情况**：使用 `-XX:MaxPermSize`（JDK 8 以前）或 `-XX:MaxMetaspaceSize`（JDK 8 及以后）参数调整大小。

#### 4. GC（Garbage Collection）问题
- **GC 暂停时间过长**：频繁的 GC 操作可能会导致应用暂停时间过长，影响响应速度。
- **检查 GC 日志**：通过 JVM 参数 `-XX:+PrintGCDateStamps` 和 `-Xloggc` 来生成 GC 日志，并分析 GC 暂停时间。

#### 5. 线程问题
- **线程阻塞**：如果大量线程处于阻塞状态，可能导致可用线程不足，进而影响应用响应。
- **检查线程状态**：使用 `jstack` 工具生成线程堆栈信息，检查是否有大量线程处于 BLOCKED、WAITING 或 TIMED_WAITING 状态。

#### 6. 直接内存溢出
- **直接内存溢出**：使用 `ByteBuffer.allocateDirect` 等方法分配的直接内存不在 JVM 堆内，但如果直接内存使用过多，也会导致 `OutOfMemoryError: Direct buffer memory`。
- **检查直接内存使用情况**：使用 `-XX:MaxDirectMemorySize` 参数来设置最大直接内存大小。

#### 7. 系统资源限制
- **文件句柄限制**：在 Linux 系统中，文件句柄数量有限，如果达到上限，可能导致无法建立新的连接。
- **检查系统资源限制**：使用 `ulimit -a` 命令查看当前系统的资源限制，并适当调整。

#### 排查步骤建议
1. **查看日志**：首先查看应用的日志输出，寻找是否有异常信息，特别是 JVM 相关的异常。
2. **监控内存使用情况**：使用工具如 VisualVM、JConsole 等监控应用的内存使用情况，特别是堆内存和永久代/元空间。
3. **生成堆转储文件**：使用 `jmap` 工具生成堆转储文件，并使用 MAT、JProfiler 等工具分析内存泄漏。
4. **分析 GC 日志**：使用 `-XX:+PrintGCDetails` 等参数生成详细的 GC 日志，并分析 GC 暂停时间和频率。
5. **生成线程堆栈信息**：使用 `jstack` 工具生成线程堆栈信息，并检查是否有大量线程处于非活跃状态。
6. **调整 JVM 参数**：根据分析结果调整 JVM 的相关参数，如堆内存大小、GC 算法、直接内存大小等。

通过上述步骤，可以较为全面地排查内存和 JVM 方面的问题，并针对性地进行优化。如果问题仍然无法解决，建议进一步寻求专业的技术支持。

### 怎么检测程序发生了死锁

检测死锁通常需要结合具体的工具和技术手段来进行。通过使用 jstack、ThreadMXBean、VisualVM 或 IDE 的调试功能等工具，可以有效地检测和诊断 Java 应用程序中的死锁问题。一旦检测到死锁，还需要进一步分析代码逻辑，优化锁的使用策略，以避免死锁的发生

jstack 是一个非常有用的命令行工具，**用于打印 Java 进程中的所有线程的堆栈跟踪信息。**这对于诊断死锁、挂起的线程以及其他与线程相关的故障非常有帮助。jstack 可以帮助开发者理解每个线程当前的状态和执行的位置，从而更容易地找出问题所在。

jstack 的用途
**检测死锁：通过查看线程的堆栈信息，可以检测是否存在多个线程互相等待对方释放锁的情况。**
诊断挂起的线程：当某个线程长时间处于 BLOCKED 或 WAITING 状态时，可以使用 jstack 查看该线程的详细信息。
分析线程状态：可以查看所有线程的状态（如 RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED 等）。

### 手写一个死锁案例，要求一定发生死锁

死锁的危害非常巨大，是并发编程必须要考虑的问题。不过好在死锁的产生条件比较严苛，需要同时满足四个**必要**条件：

- **互斥条件**：一个资源同时最多能被一个线程持有
- **请求与保持条件**：一个线程因请求其他资源而被阻塞时，不会释放已持有的资源
- **不剥夺条件**：线程执行完成之前，其他的线程不能抢占该线程持有的资源
- **循环等待条件**：多个线程请求的资源形成一个等待环

既然知道了死锁产生的四个必要条件，所以只需要破坏其中一个或者多个即可。

- 对于互斥条件，想要破坏它，就是能加共享锁的就不要加独占锁
- 对于请求与保持条件，可以设置超时时间，阻塞一段时间后，如果还未获取到锁，就释放自己持有的锁；或者死锁发生时，调度者强行中断某个死锁的状态，并释放持有的资源
- 对于不剥夺条件，请求资源（锁）时，使用可以响应中断的锁，例如Lock.lockInterruptibly()
- 对于循环等待条件，这个条件相对来说是最好破坏的。只需要打破等待环即可。线程请求多把锁的时候，做到按顺序请求锁（每个线程），这样就不会形成等待环。

```java

    public class DeadLock {
        final private static Object lock1 = new Object();
        final private static Object lock2 = new Object();
        public static void main(String[] args) {
            Thread thread1 = new Thread(() -> {
                synchronized (lock1) {
        // 先获取lock1
                    System.out.println("thread-1 get lock1");
                    try {
        // 休眠200毫秒，让thread-2获取lock2
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (lock2) {
        // 在lock1同步代码中获取lock2
                        System.out.println("thread-1 get lock2");
                    }
                }
                System.out.println("thread-1 finished");
            }, "thread-1");
            Thread thread2 = new Thread(() -> {
                synchronized (lock2) {
        // 先获取lock2
                    System.out.println("thread-2 get lock2");
                    synchronized (lock1) {
        // 在lock2同步代码中获取lock1
                        System.out.println("thread-2 get lock1");
                    }
                }
                System.out.println("thread-2 finished");
            }, "thread-2");
            thread1.start();
            thread2.start();
        }
    }

```

thread-1 get lock1
thread-2 get lock2
例子共有6行输出，但是只输出了2行。不仅如此，用IDE运行该代码时，IDE永远不会执行结束。对于本次运行结果，thread-1首先获取CPU时间片，开始执行，获取锁lock1，输出thread-1 get lock1，然后休眠200毫秒。在200毫秒内thread-2获取CPU时间片，开始执行，获取lock2，输出thread-2 get lock2。此时tread-1必须获取lock2才能继续执行，执行完成才能释放自己持有的lock1。而thread-2同理，想要继续执行，必须先获取thread-1持有的lock1，执行完成才能释放lock2。就这样，两个线程发生了死锁。导致后续的代码都不会执行，之后的语句并不会输出。

### MySQL事务的实现原理

数据库中的「事务（Transaction）」就能达到这样的效果。
我们在转账操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。**事务是逻辑上的一组操作，要么都执行，要么都不执行。**

#### 事务有哪些特性？

- 事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。
- 比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。

1. 原子性 Atomicity

2. 一致性 Consistency

3. 隔离性 Isolation

   防止多个事务并发执行时由于交叉执行而导致数据的不一致

4. 持久性 Durability

InnoDB引擎通过什么来保证事务这四个特性的呢？

1. 原子性是通过 **undo log（回滚日志）** 来保证的；
2. 隔离性是通过 **MVCC（多版本并发控制） 或锁机制**来保证的；
3. 持久性是通过 **redo log （重做日志**）来保证的；
4. 一致性则是通过持久性+原子性+隔离性来保证；

**即，AID是手段，C是目的**

### redolog日志的作用

- Buffer Pool 是基于内存的，而内存总是不可靠，**万一断电重启，还没来得及落盘的脏页数据就会丢失。**

- 当有一条记录**需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，**这个时候更新就算完成了。

  - **redolog是物理日志，每执行一个事务就会产生这样的一条或多条物理日志。在事务提交时，先将 redo log 持久化到磁盘即可**，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。

- **InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL （Write-Ahead Logging）技术。**WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。

- **开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。在内存修改该 Undo 页面后，需要记录对应的 redo log。**

- redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；
  undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；

  事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务。

- **实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；**

- **将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能。**

### binlog与redolog的区别

1. 使用对象不同

   1. binlog——MySQL的server层实现的日志，所有的存储引擎都可以使用
   2. redolog——InnoDB存储引擎实现的日志

2. 文件格式不同

   1. binlog

      1. STATEMENT

         **每一条修改数据的 SQL 都会被记录到 binlog 中**（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。

         但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；

      2. ROW

         **记录行数据最终被修改成什么样了**（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。

         但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；

      3. **MIXED**

         **包含statement和row，自动选择使用哪种**

   2. redolog 物理日志

3. 写入方式不同

   1. binlog——**追加写，写满一个文件创建一个新的，不会覆盖之前的**
   2. redolog——循环写，日志空间大小固定，全部写满从头开始，保存未被刷入磁盘的脏页日志

4. 用途不同

   1. binlog**——备份复制，主从复制**
   2. redolog——**用于掉电等故障恢复**

   将数据库的数据删除了，不可以用redolog恢复，只能用binlog，因为redolog记录的是未被写入磁盘的数据的物理日志，边写边擦除。

### 有了解过哪些分布式一致性的协议

好的，以下是几种常见的分布式一致性协议的简要介绍：

### 1. Paxos 协议
- **简介**：一种经典的分布式一致性协议，通过多轮投票机制来达成一致。
- **特点**：支持强一致性，但实现复杂。
- **应用场景**：数据库、分布式存储系统。

### 2. Raft 协议
- **简介**：一种易于理解和实现的一致性协议，通过选举领导者来集中控制一致性问题。
- **特点**：直观易懂，易于实现。
- **应用场景**：分布式存储系统、配置管理。

### 3. ZAB 协议
- **简介**：ZooKeeper 使用的一致性协议，支持普通模式和恢复模式。
- **特点**：适用于分布式协调服务。
- **应用场景**：分布式协调服务，如 ZooKeeper。

### 4. PBFT 协议
- **简介**：解决拜占庭将军问题的一致性协议，通过预准备、准备和提交三个阶段达成一致。
- **特点**：支持容错性。
- **应用场景**：区块链、分布式账本技术。

### 5. Chord 协议
- **简介**：一种分布式哈希表（DHT）协议，通过环形拓扑结构实现一致性。
- **特点**：适用于 P2P 网络。
- **应用场景**：P2P 网络、分布式存储系统。

### 6. Dynamo 协议
- **简介**：Amazon 开发的分布式键值存储系统，支持概率一致性。
- **特点**：支持弱一致性，高可用性和容错性。
- **应用场景**：高可用性和分区容错性强的分布式存储系统。

这些协议各自适用于不同的场景，根据具体的需求选择合适的协议非常重要。
