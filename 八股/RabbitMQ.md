# RabbitMQ

## 什么是RabbitMQ

- 消息队列是一个使用队列来通信的组件。
- RabbitMQ是一个基于AMQP（Advanced Message Queueing Protocol）标准的消息中间件。

## RabbitMQ特点

- 可靠性：使用**持久化、传输确认、发布确认**等机制保证可靠性
- 灵活的路由：在消息进入队列之前，通过交换器路由消息。
  - 典型路由功能：提供内置交换器实现
  - 更复杂的路由功能：将多个交换器绑定在一起，也可以通过插件机制来实现自己的路由
- 扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态的扩展集群中的节点。
- 高可用性：队列可以在集群中的机器上设置镜像，使得部分节点出现问题的情况下队列仍然可用。
- 多种协议：原生支持AMQP，还支持STOMP。MQTT等多种消息中间件协议。
- 多语言客户端：几乎支持所有常用语言
- 管理界面：提供一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。
- 插件机制：提供多种机制来扩展

## RabbitMQ核心概念

RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息

![图1-RabbitMQ 的整体模型架构](D:\2024\Notes\Typora\八股\RabbitMQ.assets\96388546.jpg)

### Producer 生产者和Consumer 消费者

- 消息由两部分组成

  - 消息头 Label

    由一系列的可选属性组成

    - routing-key 路由键
    - priority 优先级
    - delivery-mode 指出该消息可能需要持久性存储

  - 消息体 payLoad

    不透明

- 生产者把消息交由MQ以后，RabbitMQ会根据消息头把消息发送给感兴趣的消费者

### Exchange 交换器

1. 在 RabbitMQ 中，消息并不是直接被投递到 **Queue(消息队列)** 中的，中间还必须经过 **Exchange(交换器)** 这一层，**Exchange(交换器)** 会把我们的消息分配到对应的 **Queue(消息队列)** 中。
2. **Exchange(交换器)** 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，**或许会返回给 Producer(生产者) ，或许会被直接丢弃掉** 。这里可以将 RabbitMQ 中的交换器看作一个简单的实体。
   1. **RabbitMQ 的 Exchange(交换器) 有 4 种类型，不同的类型对应着不同的路由策略**：**direct(默认)**，**fanout**, **topic**, 和 **headers**，不同类型的 Exchange 转发消息的策略有所区别



1. 生产者将消息发给交换器的时候，一般会指定一个Routing Key路由键，用来指定这个消息的路由规则，

   **这个Routingkey需要与交换器类型和绑定键bindkey联合使用才能生效**

2. Exchange交换器与Queue消息队列关联需要通过binding绑定，**在绑定的时候一般会指定一个bindingkey绑定键**，这样RabbitMQ就知道如何正确将消息路由到消息队列里。

3. **一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则**，所以可以将交换器理解成一个由绑定构成的路由表。Exchange和消息队列可以是多对多的关系



1. **生产者将消息发送给交换其实，需要一个RoutingKey**，当BindingKey和RoutingKey匹配时，消息会被路由到对应的队列中
2. 再绑定多个队列到同一个交换器的时候，允许使用相同的BindingKey，BindingKey并不是在所有情况下都生效，依赖于交换机的类型
   1. fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。

### Queue 消息队列

- Queue(消息队列) 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。
- **RabbitMQ 中消息只能存储在 队列 中，**这一点和 Kafka 这种消息中间件相反。Kafka 将消息存储在 topic（主题） 这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移标识。 **RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。**
- 多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。
  - RabbitMQ不支持队列层面的广播消费

### Broker 消息中间件的服务节点

一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者 RabbitMQ 服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。

![image-20241007190820073](D:\2024\Notes\Typora\八股\RabbitMQ.assets\image-20241007190820073.png)

### Exchange Types 交换器类型

1. **fanout**

   1. 把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中
   2. 速度最快、用于广播消息

2. **direct**

   1. 把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。
   2. 用于处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。

3. **topic**

   1. 也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中
   2. 不同点：
      1. RoutingKey为一个点号“.”分割的字符串
      2. BindingKey和RoutingKey一样也是点号“.”分割的字符串
      3. BindingKey 中可以存在两种特殊字符串“\*”和“#”，用于做模糊匹配。其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。

4. **headers**

   根据发送的消息内容中的 headers 属性进行匹配

5. system

6. 自定义

## 什么是AMQP

RabbitMQ 就是 AMQP 协议的 Erlang 的实现(当然 RabbitMQ 还支持 STOMP2、 MQTT3 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定

1. AMQP 协议的三层：
   1. Module Layer:协议最高层，主要定义了一些**客户端调用的命令**，客户端可以用这些命令实现自己的业务逻辑。
   2. Session Layer:中间层，**主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理**。
   3. TransportLayer:最底层，**主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等**。
2. AMQP模型的三大组件
   1. 交换器：消息代理服务器中用于把消息路由到队列的组件
   2. 队列：用来存储消息的数据结构，位于硬盘或者内存中
   3. 绑定：一套规则，告知交换器应该将消息投递到哪个队列中

## 说说生产者Producer和消费者Consumer

**生产者** :

- 消息生产者，就是投递消息的一方。
- 消息一般包含两个部分：消息体（`payload`)和标签(`Label`)。

**消费者**：

- 消费消息，也就是接收消息的一方。
- **消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签**

## 说说Broker服务节点、Queue队列、Exchange交换器

- Broker：可以看做 RabbitMQ 的服务节点。一般情况下一个 Broker 可以看做一个 RabbitMQ 服务器。
- Queue：RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。
- Exchange：生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。

##  什么是死信队列？如何导致的？

DLX，全称为 Dead-Letter-Exchange，死信交换器，死信邮箱。当消息在一个队列中变成死信 (dead message) 之后，**它能被重新发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。**

导致的死信的几种原因：

- 消息**被拒**（Basic.Reject /Basic.Nack) 且 requeue = false。
- 消息 **TTL 过期。**
- **队列满了，无法再添加。**

## 什么是延迟队列？RabbitMQ怎么实现延迟队列

延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是**等待特定时间后，消费者才能拿到这个消息进行消费。**

RabbitMQ 本身是没有延迟队列的，要实现延迟消息，一般有两种方式：

1. 通过 RabbitMQ 本身队列的特性来实现，**需要使用 RabbitMQ 的死信交换机（Exchange）和消息的存活时间 TTL（Time To Live）。**
   1. 首先，需要创建一个 DLX，当消息过期时，这些消息将会被发送到 DLX 中。
   2. 接下来，创建一个普通的队列，并设置它的参数，使得当消息过期后，消息会发送到之前创建的 DLX 中
   3. 发送消息时，可以将消息发送到普通队列中。这些消息将在设定的时间后过期，并自动转移到 DLX。
   4. 最后，需要创建另一个队列来监听 DLX，并处理那些过期
2. 在 RabbitMQ 3.5.7 及以上的版本**提供了一个插件**（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖 Erlang/OPT 18.0 及以上。

也就是说，AMQP 协议以及 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过 TTL 和 DLX 模拟出延迟队列的功能。

## 什么是优先级队列

RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。

可以通过`x-max-priority`参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义

## RabbitMQ有哪些工作模式

- 简单模式
- work 工作模式
- pub/sub 发布订阅模式
- Routing 路由模式
- Topic 主题模式

## RabbitMQ消息怎么传输

由于 **TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈**，所以 **RabbitMQ 使用信道的方式来传输数据**。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，信道是**建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理**，这个 **TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，**每个信道对应一个线程使用

## 如何保证消息的可靠性

消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。

- 生产者到 RabbitMQ：**事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。**
- RabbitMQ 自身：**持久化、集群、普通模式、镜像模式。**
- RabbitMQ 到消费者：**basicAck 机制、死信队列、消息补偿机制。**

## 如何保证RabbitMQ消息的顺序性

- 拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；
- 或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理

## 如何保证RabbitMQ高可用的

R**abbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，**我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。**RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。**

- 单机模式

  Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式。

- 普通集群模式

  意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。**你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（**元数据可以认为是 queue 的一些配置信息，**通过元数据，可以找到 queue 所在实例）。**

  你消费的时候，实际上**如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。**

- 镜像集群模式

  这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是**，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上**，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。**然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。**RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。

  这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于**，第一，这个性能开销也太大了吧**，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据

## 如何解决消息队列的**延时以及过期失效**问题

RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果**消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，**这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。
