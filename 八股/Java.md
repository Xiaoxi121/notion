# Java

## 基础

### 基础概念和常识

- **面向对象** 封装、继承、多态

- 支持**多线程**

- 一次编写、随处运行的**平台无关性**

  **强大的生态**

- **可靠性**（异常处理和**自动内存管理机制**）

  **安全性**（多重安全按保护机制如访问权限限制符、限制程序直接访问操作系统资源）

  **高效性**

### Java se or ee

standard edition\enterprise edition

Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。

### JDK JRE JVM

JDK》JRE》JVM

#### JDK、JRE

JDK 不仅包含 JRE，还包括用于开发和调试 Java 程序的工具。JRE 只包含运行 Java 程序所需的环境和类库

JDK，java development,一个功能齐全的 Java 开发工具包，包含

- JRE,java runtime environment
  - JVM
  - Java基础类库
- 编译器javac和其他工具，例如
  - javadoc文档生成器
  - jdb调试器
  - jconsole监控工具
  - Javap反编译工具

#### JVM

java virtual machine，**是运行 Java 字节码的虚拟机**，有针对不同系统的特定实现（Windows，Linux，macOS），目的是**使用相同的字节码，它们都会给出相同的结果。**字节码和**不同系统的 JVM 实现**是 Java 语言“一次编译，随处可以运行”的关键所在。

#### 不用区分JDK和JRE 

在java9引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。也就是说，可以用 jlink 根据自己的需求，创建一个更小的 runtime（运行时），**而不是**不管什么应用，都是同样的 JRE。

### 什么是字节码？好处？

-  JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机
-  由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。
-  java**程序转变为机器代码的过程**
   - **.java->javac编译->.class->判断是否是热点代码**
     - **是-》JIT-》直接使用**
     - **不是-》解释器-》使用**
-  我们需要格外注意的是 .class->机器码 这一步。
   - 在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的**热点代码**)，
   - 所以后面引进**了 JIT（Just in Time Compilation） 编译器，而 JIT 属于运行时编译**。当 JIT 编译器完成第一次编译后，其会**将字节码对应的机器码保存下来，下次可以直接使用**。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这解释了我们为什么经常会说 Java 是编译与解释共存的语言 。

### 为什么说Java语言编译与解释共存？

- 编译型：编译型语言会**通过编译器将源代码一次性翻译成可被该平台执行的机器码。**

  一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。

- 解释型：解释型语言**会通过解释器一句一句的将代码解释（interpret）为机器代码后**再执行。

  解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

- Java 语言既具有编译型语言的特征，也具有解释型语言的特征。

  因为 Java 程序**要经过先编译，后解释两个步骤**，

  ​	由 Java 编写的程序需要先经过**编译步骤，生成字节码（.class 文件）**，

  ​	这种**字节码必须由 Java 解释器**来解释执行

### AOT有什么优点？为什么不全部使用AOT

Ahead of Compilation

和 JIT 不同的是，这种编译模式会**在程序被执行前就将其编译成机器码，属于静态编译**（C、 C++，Rust，Go 等语言就是静态编译）。

AOT优点:

1. 启动时间：避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长
2. 内存占用
3. 打包体积
4. 增强安全性：AOT 编译后的代码不容易被反编译和修改

JIT优点：

- 具备更高的极限处理能力，可以降低请求的最大延迟。

### Oracle JDK vs Open JDK

- **OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的**

### Java和C++的区别

- 内存：
  - Java **不提供指针**来直接访问内存，程序内存更加安全
  - Java 有**自动内存管理垃圾回收机制(GC)，**不需要程序员手动释放无用内存。

- 继承：
  - **Java 的类是单继承的**，C++ 支持多重继承；
  - 虽然 Java 的类不可以多继承，但是**接口可以多继承。**
- 重载：
  - C ++同时支持方法重载和操作符重载，但是 **Java 只支持方法重载**（操作符重载增加了复杂性，这与 Java 最初的设计思想不符

### ------基本语法------

### 注释有哪几种形式

单行、多行、文档

### 标识符和关键字的区别？

- 标识符就是一个名字 。关键字是被赋予特殊含义的标识符
- **所有的关键字都是小写的**
- **default 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。**

### 移位运算符

优点：

1. 高效：**移位运算符直接对应于处理器的移位指令**。现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。
2. 节省内存：通过移位操作，**可以使用一个整数（如 int 或 long）来存储多个布尔值或标志位**，从而节省内存

类型

- << :左移运算符，向左移若干位，高位丢弃，低位补零。x << n,相当于 x 乘以 2 的 n 次方(不溢出的情况下)。
- />>：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x >> n,相当于 x 除以 2 的 n 次方。
- />>>:无符号右移，忽略符号位，空位都以 0 补齐

移位操作符实际支持类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。

#### 如果移位的位数超过数值所占有的位数会怎么样？

**当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。**也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。
	**也就是说：x<<42等同于x<<10，x>>42等同于x>>10，x >>>42等同于x >>> 10。**

### ---基本数据类型----

### java中的基本数据类型了解吗

Java 中有 8 种基本数据类型，分别为：

- 6 种数字类型：
  - 4 种整数型：byte、short、int、long
    - ​    8、16、32、64
  - 2 种浮点型：float、double
    - 32、64
- 1 种字符类型：char
  - 16
- 1 种布尔型：boolean
  - 8

- Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。
- Java 里使用 float 类型的数据一定要在数值后面加上 f 或 F，否则将无法通过编译。
- char a = 'h'char :单引号，String a = "hello" :双引号。
- 这八种基本类型都有对应的包装类分别为：Byte、Short**、Integer**、Long、Float、Double、**Character、**Boolean

### 数据类型转换方式？

1. 自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为long、将float转换为double等。
2. 强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将long转换为int、将double转换为int等。语法为：目标类型 变量名 = (目标类型) 源类型。
3. 字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double，可以使用Double.parseDouble()方法等。
4. 数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法

### 类型互转会出现什么问题？

1. 数据丢失：**当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。**例如，将一个long类型的值转换为int类型时，如果long值超出了int类型的范围，转换结果将是截断后的低位部分，高位部分的数据将丢失。
2. 数据溢出**：与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。**例如，将一个int类型的值转换为long类型时，转换结果会填充额外的高位空间，但原始数据仍然保持不变。
3. 精度损失：**在进行浮点数类型的转换时，可能会发生精度损失。**由于浮点数的表示方式不同，将一个单精度浮点数(float)转换为双精度浮点数(double)时，精度可能会损失。
4. 类型不匹配导致的错误：在进行类型转换时，需要确保源类型和目标类型是兼容的。**如果两者不兼容，会导致编译错误或运行时错误**

### 基本类型和包装类型的区别？

- 用途
  - 除了**定义一些常量和局部变量**之外，我们在其他地方比如**方法参数、对象属性中很少会使用基本类型来定义变量。**
  - **包装类型可用于泛型，而基本类型不可以**
- 存储方式
  - 基本数据类型的**局部变量**存放在 Java 虚拟机**栈中**的**局部变量表**中
  - 基本数据类型的**成员变量（未被 static 修饰 ）**存放在 J**ava 虚拟机的堆**中
  - **包装类型属于对象类型**，我们知道**几乎**所有对象实例都存在于**堆**中。
- 占用空间
  - 相比于包装类型（对象类型），**基本数据类型占用的空间往往非常小。**
- 默认值
  - **成员变量包装类型不赋值就是 null**，**基本类型有默认值且不是 null**
- 比较方式
  - 基本数据类型来说，**== 比较的是值**
  - 对于包装数据类型来说，== 比较的是**对象的内存地址**。所有**整型包装类对象之间值的比较，全部使用 equals() 方法。**

### 包装类型的缓存机制了解吗

- **Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。**
- **如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。**

### 自动拆装箱了解吗？什么原理？

- 装箱：将基本类型用它们对应的引用类型包装起来；	
  - 自动装箱发生情况
    1. **赋值时**
    2. **方法调用时**

  - 自动装箱弊端
    - **在循环中进行自动装箱操作的情况，就会创建多余的对象，影响程序性能。**
- 拆箱：将包装类型转换为基本数据类型；
- 从字节码中可以发现**装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。**

### Java为什么要有Integer

1. Integer对应是int类型的包装类，**就是把int类型包装成Object对象，**对象封装有很多好处，**可以把属性也就是数据跟处理这些数据的方法结合在一起，**比如Integer就有parseInt()等方法来专门处理int型相关的数据。
2. 另一个非常重要的原因就**是在Java中绝大部分方法或类都是用来处理类类型对象的**，如ArrayList集合类就只能以类作为他的存储对象，而这时**如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。**

1. 泛型中的应用

   在Java中，**泛型只能使用引用类型，而不能使用基本类型**

2. 转换中的应用

   在Java中，**基本类型和引用类型不能直接进行转换，必须使用包装类来实现。**

3. 集合中的应用

   Java集合中只能存储对象，而不能存储基本数据类型

### Integer相比int有什么优点？

1. 基本类型和引用类型：**首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用int来存储一个整数时，不需要任何额外的内存分配**，而使用Integer时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。
2. 自动装箱和拆箱：其**次，Integer作为int的包装类，它可以实现自动装箱和拆箱。**自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。
3. 空指针异常：另外，**int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。**这是因为它被赋予了null值，而null值是无法进行自动拆箱的

### 为什么还要保留int？

1. 读写效率：

   **包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。因此，基本类型数据在读写效率方面，要比包装类高效**

2. 存储效率：

   **在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。**

### Integer的缓存

​	Java的Integer类**内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。**

​	默认情况下，这个范围是-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。

### 为什么浮点数运算的时候会有精度丢失的风险？

计算机是**二进制**的，而且计算机在表示一个数字时，**宽度是有限**的，**无限循环的小数存储在计算机时，只能被截断**，所以就**会导致小数精度发生损失**的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。

### 如何解决浮点数运算的精度丢失问题

- 浮点数之间的等值判断**，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。（**equals会比较值和精度）
- BigDecimal 可以**实现对浮点数的运算，不会造成精度丢失。**
- 我们在使用 BigDecimal 时，为了防止精度丢失，推荐使用它的BigDecimal(String val)构造方法或者 BigDecimal.valueOf(double val) 静态方法来创建对象。

### 超过long整型的数据应该如何表示

**BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。**
相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低

### ---------变量--------

###  成员变量与局部变量的区别

- 语法形式
  - **成员变量是属于类的**，而局部变量是**在代码块或方法中定义的变量或是方法的参数；**
  - 成员变量**可被 public,private,static 等修饰符修饰，****局部变量不能被访问控制修饰符及 static 所修饰；**
  - 但是，成员变量和局部变量都能被 final 所修饰
- 存储方式
  - 成员变量**是使用 static 修饰的，那么这个成员变量是属于类的，是对象的一部分**
  - **没有使用 static 修饰，这个成员变量是属于实例的。**
  - 而**对象存在于堆**内存，**局部变量则存在于栈**内存。
- 生存时间
  - 从变量在内存中的生存时间上看，**成员变量是对象的一部分，它随着对象的创建而存在**
  - 而**局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。**
- 默认值
  - 从变量是否有默认值来看，**成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值**（一种情况例外:**被 final 修饰的成员变量也必须显式地赋值**）
  - 而**局部变量则不会自动赋值。**

#### 为什么成员变量有默认值？

- 先不考虑变量类型，如果**没有默认值会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。**
- 默认值有两种设置方式：手动和自动，根据第一点，**没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。**
- 对于编译器（javac）来说，局**部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，**误报“没默认值”又会影响用户体验，所以采用自动赋默认值。

### 静态变量有什么作用

- 静态变量也就是被 static 关键字修饰的变量。它可以**被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也**就是说，静态变量**只会被分配一次内存**，即使创建多个对象，这样可以**节省内存。**
- 通过类名来访问
- 通常情况下，静态变量会被 final 关键字修饰成为常量。

### 字符型常量和字符串常量的区别

- 形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
- 含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。
- 占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。
- ⚠️ 注意 char 在 Java 中占两个字节。

### ---------方法--------

### 静态方法为什么不能调用非静态方法

- **静态方法是属于类的**，在**类加载的时候就会分配内存**，可以**通过类名直接访问。**
  **非静态成员属于实例对象**，只有在**对象实例化之后才存在**，需要通**过类的实例对象去访问。**
- **在类的非静态成员不存在的时候静态方法就已经存在了**，此时调用在内存中还不存在的非静态成员，属于非法操作。

### 静态方法和实例方法有什么不同

1. 调用方法

   在**外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式**，**而实例方法只有后面这种方式**。也就是说，调用静态方法可以无需创建对象 。

   需要注意的是一般不建议使用 对象.方法名 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。
   因此，**一般建议使用 类名.方法名 的方式来调用静态方法。**

2. 访问类成员是否存在限制

   静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。

### 静态变量和静态方法

在Java中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联**。它们在内存中只存在一份，可以被类的所有实例共享。**

- 静态变量

  静态变量（也称为类变量）是在类中使用static关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：

  - 共享性**：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。**
  - 初始化：静态变量在类被加载时初始化，**只会对其进行一次分配内存。**
  - 访问方式：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。

- 静态方法

  静态方法是在类中使用static关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：

  - 无实例依赖：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。
  - 访问静态成员：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。
  - 多态性：静态方法不支持重写（Override），但可以被隐藏（Hide）。

- 使用场景

  - 静态变量：常用于需要在所有对象间共享的数据，如计数器、常量等。
  - 静态方法：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理。

### 静态内部类和非静态内部类

- **非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。**
- 非静态内部类**可以访问外部类的实例变量和方法**，而静态内部类只能访问外部类的静态成员。
  非静态内部类**不能定义静态成员**，而静态内部类可以定义静态成员。
- 非静态内部类**在外部类实例化后才能实例化**，而静态内部类可以独立实例化。
- 非静态内部类可**以访问外部类的私有成员，**而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。

### 非静态内部类为什么可以直接访问外部方法？

**非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。**

这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。

### 父类和子类加载顺序

1. **父类静态成员变量、静态代码块（如果有）**
2. **子类静态成员变量、静态代码块（如果有）**
3. **父类构造方法（实例化对象时）**
4. **子类构造方法（实例化对象时）**

### 重载和重写的区别

简单说：

- 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
- 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法



- 重载发生在**编译期**，就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理
- 重写发生在**运行期**，是子类对父类的允许访问的方法的实现过程进行重新编写。
  - 方法名、参数列表必须相同，
  - **子类方法返回值类型应比父类方法返回值类型更小或相等，**
    - 如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。
  - **抛出的异常范围小于等于父类，**
  - **访问修饰符范围大于等于父类。**
  - **如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。**
  - **构造方法无法被重写**

### 什么是可变长参数

- 从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。
- 可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。
- 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？
  答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。
- Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 class文件就可以看出来了。

### -----面向对象-------

### 面向对象和面向过程的区别

面向过程编程（POP）：面向过程把**解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。**
面向对象编程（OOP）：面向**对象会先抽象出对象，然后用对象执行方法的方式解决问题。**

### 构造方法有哪些特点，是否可以被重载？

- 名称与类名相同：构造方法的名称必须与类名完全一致。
- 没有返回值：构造方法没有返回类型，且不能使用 void 声明。
- 自动执行：在生成类的对象时，构造方法会自动执行，无需显式调用。

构造方法不能被重写（override），但可以被重载（overload）。因此，一个类中可以有多个构造方法，这些构造方法可以具有不同的参数列表，以提供不同的对象初始化方式。

### 面向对象三大特征

#### 封装

封装是指把一个对象的状态信息（也就是属**性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性**

#### 继承

**继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。**

- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。（以后介绍）。

#### 多态

**表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例**

- **对象类型和引用类型之间具有继承（类）/实现（接口）的关系；**
- **引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；**
- **多态不能调用“只在子类存在但在父类不存在”的方法；**
- 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法

##### 多态体现在哪几个方面

1. 方法重载

   方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。

2. 方法重写

   方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。

3. 接口与实现

   多态也体现在接口的使用上，多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。

4. 向上向下转型

   在Java中，可以使用父类类型的引用指向子类对象，这是向上转型。通过这种方式，可以在运行时期采用不同的子类实现。

##### 多态解决的问题

1. 多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类。
2. 多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等

### 面向对象的设计原则

1. 单一职责原则（SRP）：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。
2. 开放封闭原则（OCP）：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。
3. 里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。
4. 接口隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。
5. 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。
6. 最少知识原则 (Law of Demeter)：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。

### 创建对象的方式

1. 使用new关键字

   通过new关键字直接调用类的构造方法来创建对象

2. 使用Class类的newInstance()方法

   通过反射机制，可以使用Class类的newInstance()方法创建对象。

3. 使用Constructor类的newInstance()方法

   同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。

4. 使用clone()方法

   如果类实现了Cloneable接口，可以使用clone()方法复制对象。

5. **使用反序列化**

   通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。

### 

### 接口和抽象类有什么共同点和区别？

#### 共同点

- 实例化：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。
- 抽象方法：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。

#### 区别

- 设计目的：接口主要用于对类的行为进行约束，你**实现了某个接口就具有了对应的行为**。
  	**抽象类主要用于代码复用**，强调的是所属关系。
- 继承和实现：一个类**只能继承一个类**（包括抽象类），因为 Java 不支持多继承。
      **但一个类可以实现多个接口**，**一个接口也可以继承多个其他接口。**
- 成员变量：**接口中的成员变量只能是 public static final 类型的，****不能被修改且必须有初始值。**
      **抽象类的成员变量可以有任何修饰符**（private, protected, public），可以在子类中被重新定义或赋值。
- 方法：
  - Java 8 之前，接口中的方法默认是 public abstract ，也就是只能有方法声明。
    自 Java 8 起，可以在接口中定义 default（默认） 方法和 static （静态）方法。 
    自 Java 9 起，接口可以包含 private 方法。
  - **抽象类可以包含抽象方法和非抽象方法**。
    抽象方法没有方法体，必须在子类中实现。
    非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。

### 接口里面可以定义哪些方法？

1. 抽象方法

   抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是 public 和 abstract，这些修饰符可以省略。

2. 默认方法

   默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。

3. 静态方法

   静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。

4. 私有方法

   私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。

### 接口可以包含构造函数吗

在接口中，不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为**接口不会有自己的实例的，所以不需要有构造函数。**

### 抽象类和普通类区别

1. 实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。
2. 方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。
3. 继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。
4. 实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。

### 抽象类可以被实例化吗

- 在Java中，抽象类本身不能被实例化。
- 这意味着不能使用new关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由abstract关键字修饰且无方法体的方法），这些方法需要在子类中被实现。
- **抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。**

简而言之，抽象类不能直接实例化，但通过继承抽象类并实现所有抽象方法的子类是可以被实例化的。

### 抽象类不能加final修饰

不能，**Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。**

### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

- 浅拷贝：浅拷贝**会在堆上创建一个新的对象**（区别于引用拷贝的一点），不过，**如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址**，也就是说**拷贝对象和原对象共用同一个内部对象。**

  **浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象**

- 深拷贝：**深拷贝会完全复制整个对象，包括这个对象所包含的内部对象**

  **深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象**

- 那什么是引用拷贝呢？ 简单来说，**引用拷贝就是两个不同的引用指向同一个对象。**

### 实现深拷贝的三种方式

1. **实现 Cloneable 接口并重写 clone() 方法**

   这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。

2. **使用序列化和反序列化**

   通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。

3. **手动递归复制**

   针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况

### -------Object--------

### Object类的常见方法有哪些？

```java
/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class<?> getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * native 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable { }

```

### Native方法

在Java中，native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码，即用C、C++或其他语言编写的代码。native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义。
在Java类中，native方法看起来与其他方法相似，只是其方法体由native关键字代替，没有实际的实现代码。例如：

```java
public class NativeExample {
public native void nativeMethod();
}
```

要实现native方法，你需要完成以下步骤：

1. 生成JNI头文件：使用javah工具从你的Java类生成C/C++的头文件，这个头文件包含了所有native方法的原型。
2. 编写本地代码：使用C/C++编写本地方法的实现，并确保方法签名与生成的头文件中的原型匹配。
3. 编译本地代码：将C/C++代码编译成动态链接库（DLL，在Windows上），共享库（SO，在Linux上）
4. 加载本地库：在Java程序中，使用System.loadLibrary()方法来加载你编译好的本地库，这样JVM就能找到并调用native方法的实现了

### ==和equals的区别

- == 对于基本类型和引用类型的作用效果是不同的：
  - 对于基本数据类型来说，== 比较的是值。
    对于引用数据类型来说，== 比较的是对象的内存地址。
- equals() 不能用于判断基本数据类型的变量，**只能用来判断两个对象是否相等**。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法
  - 类没有重写 equals()方法：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。
  - 类重写了 equals()方法：一般我们都重写 equals()方法来比较两个对象中的**属性是否相等**；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

String 中的 equals 方法是被重写过的，**因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。**当**创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用**。如果**没有就在常量池中重新创建一个 String 对象**

### 值传递&引用传递

- 值传递：方法接收的是实参值的**拷贝，会创建副本。**
- 引用传递：**方法接收的直接是实参所引用的对象在堆中的地址**，不会创建副本，**对形参的修改将影响到实参**。

很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。不**过对于引用类型来说，值是实参的地址**

- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
  如果参数是引用类型**，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。**

### hashCode()有什么用，为什么要有？

hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置

- 如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。
- 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。

### 为什么重写equals()时必须重写hashCode()方法？

因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。

### -------String--------

### String、StringBuffer、StringBuilder区别？

|               |                            可变性                            |                          线程安全性                          |      |                             性能                             |
| :-----------: | :----------------------------------------------------------: | :----------------------------------------------------------: | ---- | :----------------------------------------------------------: |
|    String     |                     `String` 是不可变的                      |  `String` 中的对象是不可变的，也就可以理解为常量，线程安全   |      | 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象 |
| StringBuffer  | `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。 | `AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法<br /><br />`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是**线程安全**的 |      | **`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。** |
| StringBuilder |                                                              | `StringBuilder` 并没有对方法进行加同步锁，所以是**非线程安全**的。 |      | 相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 |

- 操作少量的数据: 适用 String
- 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
- 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer

### String为什么是不可变的？

我们知道被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，**final 关键字修饰的数组保存字符串并不是 String 不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）。**

String 真正不可变有下面几点原因：

- 保存字符串的数组被 final 修饰且为私有的，并且**String 类没有提供/暴露修改这个字符串的方法。**
- String 类**被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。**

### 字符串拼接用“+”还是用StringBuilder

- Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。
- 字符串对象**通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。**
- 在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。**
- StringBuilder 对象是在**循环内部被创建的，这意味着每循环一次就会创建一个 StringBuilder 对象**。**如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题了。**

### 字符串常量池了解吗

字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

### String s1 = new String("abc");这句话创建了几个字符串对象？

会创建 1 或 2 个字符串对象

1. 如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。
2. 如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。

详细来说

- 首先，代码中有一个new关键字，我们知道**new指令是创建一个类的实例对象并完成加载初始化的**，因此**这个字符串对象是在运行期才能确定的，创建的字符串对象是在堆内存上。**
- 其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，**所以它是一个字符串常量**。在首次构建这个对象时，JVM拿字面量"abc"**去字符串常量池试图获取其对应String对象的引用**。于是**在堆中创建了一个"abc"的String对象，****并将其引用保存到字符串常量池中，然后返回**；
  - 如果abc这个字符串常量不存在，则创建两个对象，**分别是abc这个字符串常量，以及new String这个实例对象。**
  - 如果abc这字符串常量存在，**则只会创建一个对象。**

### String #intern方法有什么作用？

String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：

- 如果字符串常量池中**保存了对应的字符串对象的引用，就直接返回该引用。**
- 如果字符串常量池中**没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回**

JDK 6及之前版本

在JDK 6及之前的版本中，当创建一个新的字符串对象时，例如通过*new String("1")*，**会在字符串常量池中创建一个字符串对象，并在堆中也创建一个字符串对象。**当调用*intern()*方法时，**如果常量池中已经存在相同内容的字符串对象，则返回常量池中的字符串对象。因此，字符串常量池中存储的是字符串对象。**

JDK 7及之后版本

从JDK 7开始，字符串常量池的行为发生了变化。当调用*intern()*方法时，**如果字符串常量池中不存在相同内容的字符串对象，且该字符串对象已经存在于堆中，则会将堆中的字符串对象引用添加到字符串常量池中，而不是在常量池中再创建一个新的字符串对象。**这样做可以减少不必要的内存开销。**因此，在JDK 7及之后的版本中，字符串常量池存储的既有字符串对象，也有字符串对象的引用**

### String类型的变量和常量做"+"运算时候发生了什么？

```java
String str1 = "str"; // 字符串字面量，存在于常量池中
String str2 = "ing"; // 字符串字面量，存在于常量池中
String str3 = "str" + "ing"; // 字符串字面量的拼接，结果也会被放入常量池
String str4 = str1 + str2; // 运行时拼接，不会利用常量池的优化
String str5 = "string"; // 直接赋值的字符串字面量，存在于常量池中

System.out.println(str3 == str4); // false, str3 是常量池中的引用，而 str4 是新创建的对象
System.out.println(str3 == str5); // true, str3 和 str5 都指向常量池中的同一个对象
System.out.println(str4 == str5); // false, str4 是新创建的对象，不同于 str5 的引用
```

- 对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，**字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。**

- 在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化

  - 常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之1bbb
  - 并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：
    - 基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。
      final 修饰的基本数据类型和字符串变量
    - 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）

- 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。不过，**字符串使用 final 关键字声明之后，可以让编译器当做常量来处理**。被 final 关键字修饰之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。

  ```java
  final String str1 = "str";
  final String str2 = "ing";
  // 下面两个表达式其实是等价的
  String c = "str" + "ing";// 常量池中的对象
  String d = str1 + str2; // 常量池中的对象
  System.out.println(c == d);// true
  ```

### --------异常---------

### Exception和Error的区别

所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。**Throwable 类有两个重要的子类:**

- Exception :**程序本身可以处理的异常**，可以通过 catch 来进行捕获。
  
  **Exception 又可以分为 **
  
  - **Checked Exception (受检查异常，必须处理) 和**
  - **Unchecked Exception (不受检查异常，可以不处理)。**
- Error：**Error 属于程序无法处理的错误** ，我们没办法通过 catch 来进行捕获，不建议通过catch捕获 。
  例如 
  
  - **Java 虚拟机运行错误（Virtual MachineError）、**
  - **虚拟机内存不够错误(OutOfMemoryError)、**
  - **类定义错误（NoClassDefFoundError）等** 。
  - 这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

### Checked Exception 和 Unchecked Exception 有什么区别？

#### Checked Exception

**Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。**

**除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。**常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException...。

#### Unchecked Exception

Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 **，我们即使不处理不受检查异常也可以正常通过编译。**

- 常见的有（建议记下来，日常开发中会经常用到）：
  NullPointerException(空指针错误)
  IllegalArgumentException(参数错误比如方法入参类型错误)
  NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）
  ArrayIndexOutOfBoundsException（数组越界错误）
  ClassCastException（类型转换错误）
  ArithmeticException（算术错误）
  SecurityException （安全错误比如权限不够）
  UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)

### Throwable类常用方法有哪些？

- Strin**g getMessage():** 返回异常发生时的简要描述
- String **toString():** 返回异常发生时的详细信息
- String **getLocalizedMessage():** 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同
- void **printStackTrace():** 在控制台上打印 Throwable 对象封装的异常信息

### try-catch-finally如何使用

- try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。
- catch块：用于处理 try 捕获到的异常。
- finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。

不要在 finally 语句块中使用 return! 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。

### Finally中的代码一定会被执行吗

- **程序所在的线程死亡**
- **关闭CPU**
- **finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。**

### 如何使用try-with-resources代替try-catch-finally？

- **适用范围（资源的定义）：** 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象
- 关闭资源和 finally 块的执行顺序： **在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行**

### 异常使用有哪些需要注意的地方？

- 不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。**每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。**
  **抛出的异常信息一定要有意义。**
  
  - 如果将异常定义为静态变量，以下问题可能会出现：
  
    线程安全性问题：
    如果多个线程同时访问和修改同一个静态异常对象，可能会导致数据竞争条件（race condition），从而导致异常信息的混乱或丢失。
    异常信息的覆盖：
    在多处抛出异常的情况下，如果使用静态变量存储异常，后发生的异常可能会覆盖前一次的异常信息。这会导致只记录最后一个异常的信息，而忽略了之前的错误。
    异常上下文丢失：
    异常应该是局部的，与特定的代码路径或方法调用相关联。如果使用静态变量存储异常，异常的上下文信息（如堆栈跟踪）可能无法正确反映实际的错误发生地点。
    难以追踪错误：
    当异常被定义为静态变量时，由于缺乏具体的调用堆栈信息，开发者在调试时很难准确地定位到问题发生的代码位置
  
- 建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。
- 避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决

### --------泛型---------

### 什么是泛型，有什么作用

- Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。
- 编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList<Person> persons = new ArrayList<Person>() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。

### 为什么需要泛型

1. 适用于多种数据类型执行相同的代码
2. 泛型中的类型在使用时指定，不需要强制类型转换

### 泛型的使用方式有哪几种？

泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。

1. 泛型类
2. 泛型接口
3. 泛型方法

- public static < E > void printArray( E[] inputArray ) 一般被称为**静态泛型方法;**
- 在 java **中泛型只是一个占位符，必须在传递类型后才能使用。**
- **类在实例化时才能真正的传递类型参数**，由于**静态方法的加载先于类的实例化**，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <E>

### 项目中哪里用到了泛型

- 自定义接口通用返回结果 CommonResult<T> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型
- 定义 Excel 处理类 ExcelUtil<T> 用于动态指定 Excel 导出的数据类型
- 构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）。

### --------反射---------

### 反射是什么？优缺点？

- 它赋予了我们在**运行时分析类以及执行类中方法的能力。**通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性
  - 反射可以让我们的**代码更加灵活、为各种框架提供开箱即用的功能提**供了便利。
  - 反射让我们在运行时有了分析操作类的能力的同时，也**增加了安全问题，**比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。
  - 另外，反射的**性能也要稍差点**，不过，对于框架来说实际是影响不大的。
- 发射具有以下特性：
  - **运行时类信息访问：****反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。**
  - **动态对象创建：**可以**使用反射API动态地创建对象实例，**即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。
  - **动态方法调用：**可以在**运行时动态地调用对象的方法**，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。
  - **访问和修改字段值：****反射还允许程序在运行时访问和修改对象的字段值**，即使是私有的。这是通过Field类的get()和set()方法完成的。


### 反射的应用场景

- 像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。
- 像 Java 中的一大利器 注解 的实现也用到了反射。可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解



1. 加载数据库驱动

   我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection，com.mikechen.java.oracleConnection这两个类我们要用。
   这时候我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了

2. 配置文件加载

   Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。
   Spring通过XML配置模式装载Bean的过程：

    	1. 将程序中所有XML或properties配置文件加载入内存
    	2. Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
    	3. 使用反射机制，根据这个字符串获得某个类的Class实例
    	4. 动态配置实例的属性

Java反射机制在spring框架中，很多地方都用到了反射，让我们来看看Spring的IoC和AOP是如何使用反射技术的。

##### 1、Spring框架的依赖注入（DI）和控制反转（IoC）

Spring 使用反射来实现其核心特性：依赖注入。

在Spring中，开发者可以通过XML配置文件或者基于注解的方式声明组件之间的依赖关系。当应用程序启动时，Spring容器会扫描这些配置或注解，然后利用反射来实例化Bean（即Java对象），并根据配置自动装配它们的依赖。

例如，当一个Service类需要依赖另一个DAO类时，开发者可以在Service类中使用@Autowired注解，而无需自己编写创建DAO实例的代码。Spring容器会在运行时解析这个注解，通过反射找到对应的DAO类，实例化它，并将其注入到Service类中。这样不仅降低了组件之间的耦合度，也极大地增强了代码的可维护性和可测试性。

##### 2、动态代理的实现

在需要对现有类的方法调用进行拦截、记录日志、权限控制或是事务管理等场景中，反射结合动态代理技术被广泛应用。

一个典型的例子是Spring AOP（面向切面编程）的实现。Spring AOP允许开发者定义切面（Aspect），这些切面可以横切关注点（如日志记录、事务管理），并将其插入到业务逻辑中，而不需要修改业务逻辑代码。

例如，为了给所有的服务层方法添加日志记录功能，可以定义一个切面，在这个切面中，Spring会使用JDK动态代理或CGLIB（如果目标类没有实现接口）来创建目标类的代理对象。这个代理对象在调用任何方法前或后，都会执行切面中定义的代码逻辑（如记录日志），而这一切都是在运行时通过反射来动态构建和执行的，无需硬编码到每个方法调用中。

这两个例子展示了反射机制如何在实际工程中促进松耦合、高内聚的设计，以及如何提供动态、灵活的编程能力，特别是在框架层面和解决跨切面问题时

### 反射实战

#### 获取Class对象的四种方式

如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:

1. 知道具体类的情况下

   `Class alunbarClass = TargetObject.class;`

   但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化

2. 通过class.forName()传入类的全路径获取

   `Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");`

3. 通过对象实例instance.getClass()获取

   `TargetObject o = new TargetObject();
   Class alunbarClass2 = o.getClass();`

4. 通过类加载器xxxClassLoader.loadClass()传入类路径获取

   `ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");`

   通过类加载器获取 Class 对象**不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行**

#### 反射的一些基本操作

1. 创建一个我们要使用反射操作的类 TargetObject。
2. 使用反射操作这个类的方法以及参数

### 代理模式详解

### 代理模式

我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，**扩展目标对象的功能**，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。

### 静态代理

- 静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（**比如接口一旦新增加方法，目标对象和代理对象都要进行修**改）且麻烦**(需要对每个目标类都单独写一个代理类**）
- **从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**

实现步骤：

1. 定义一个接口及其实现类；
2. 创建一个**代理类同样实现这个接口**
3. **将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。**这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

代码：

1.定义发送短信的接口

```java
public interface SmsService {
    String send(String message);
}
```

2.实现发送短信的接口

```java
public class SmsServiceImpl implements SmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
```

3.创建代理类并同样实现发送短信的接口

```java
public class SmsProxy implements SmsService {

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) {
        this.smsService = smsService;
    }

    @Override
    public String send(String message) {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method send()");
        smsService.send(message);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method send()");
        return null;
    }
}

```

4.实际使用

```java
public class Main {
    public static void main(String[] args) {
        SmsService smsService = new SmsServiceImpl();
        SmsProxy smsProxy = new SmsProxy(smsService);
        smsProxy.send("java");
    }
}
```

运行上述代码之后，控制台打印出：

```java
before method send()
send message:java
after method send()
```

可以输出结果看出，我们已经增加了 SmsServiceImpl 的send()方法

### 动态代理

- 动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，**我们可以直接代理实现类( CGLIB 动态代理机制)。**
- **从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**
- ，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。

#### JDK动态代理机制

- 在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。

-  Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。

- ```java
  public static Object newProxyInstance(ClassLoader loader,
                                        Class<?>[] interfaces,
                                        InvocationHandler h)
      throws IllegalArgumentException
  {
      ......
  }
  ```

  loader :**类加载器，用于加载代理对象。**
  interfaces : **被代理类实现的一些接口；**
  h : **实现了 InvocationHandler 接口的对象；**
  要实现动态代理的话，还必须需要**实现InvocationHandler 来自定义处理逻辑。** 当我们的动态代理对象调用一个方法时，**这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。**

  ```java
  public interface InvocationHandler {
  
      /**
       * 当你使用代理对象调用方法的时候实际会调用到这个方法
       */
      public Object invoke(Object proxy, Method method, Object[] args)
          throws Throwable;
  }
  ```

  proxy :动态生成的代理类
  method : 与代理类对象调用的方法相对应
  args : 当前 method 方法的参数
  也就是说：**你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情**

##### JDK动态代理类使用步骤

1. 定义一个接口及其实现类；
2. 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
3. 通过 Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) 方法创建代理对象

##### 代码实例

1. 定义发送短信的接口

   ```java
   public interface SmsService {
       String send(String message);
   }
   ```

2. 实现发送短信的接口

   ```java
   public class SmsServiceImpl implements SmsService {
       public String send(String message) {
           System.out.println("send message:" + message);
           return message;
       }
   }
   ```

3. 定义一个JDK动态代理类

   ```java
   import java.lang.reflect.InvocationHandler;
   import java.lang.reflect.InvocationTargetException;
   import java.lang.reflect.Method;
   
   /**
    * @author shuang.kou
    * @createTime 2020年05月11日 11:23:00
    */
   public class DebugInvocationHandler implements InvocationHandler {
       /**
        * 代理类中的真实对象
        */
       private final Object target;
   
       public DebugInvocationHandler(Object target) {
           this.target = target;
       }
   
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
           //调用方法之前，我们可以添加自己的操作
           System.out.println("before method " + method.getName());
           Object result = method.invoke(target, args);
           //调用方法之后，我们同样可以添加自己的操作
           System.out.println("after method " + method.getName());
           return result;
       }
   }
   ```

   invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。

4. 获取代理对象的工厂类

   ```java
   public class JdkProxyFactory {
       public static Object getProxy(Object target) {
           return Proxy.newProxyInstance(
                   target.getClass().getClassLoader(), // 目标类的类加载器
                   target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个
                   new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler
           );
       }
   }
   ```

   getProxy()：主要通过Proxy.newProxyInstance（）方法获取某个类的代理对象

5. 实际使用

   ```java
   SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());
   smsService.send("java");
   
   before method send
   send message:java
   after method send
   ```

#### CGLIB动态代理机制

- **JDK 动态代理**有一个最致命的问题是其**只能代理实现了接口的类。**为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。

- CGLIBopen in new window(Code Generation Library)是一个基于ASMopen in new window的字节码生成库，它**允许我们在运行时对字节码进行修改和动态生成。**CGLIB **通过继承方式实现代理**。很多知名的开源框架都使用到了CGLIBopen in new window， 例如 Spring 中的 **AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。**

- 在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。
  你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。

  ```java
  public interface MethodInterceptor
  extends Callback{
      // 拦截被代理类中的方法
      public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable;
  }
  ```

  obj : 被代理的对象（需要增强的对象）
  method : 被拦截的方法（需要增强的方法）
  args : 方法入参
  proxy : 用于调用原始方法
  **你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法**

##### CGLIB动态代理类使用步骤

- 定义一个类；
- 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；
- 通过 Enhancer 类的 create()创建代理类；

##### 代码示例

1. 使用一个阿里云发送短信的类

   ```java
   package github.javaguide.dynamicProxy.cglibDynamicProxy;
   
   public class AliSmsService {
       public String send(String message) {
           System.out.println("send message:" + message);
           return message;
       }
   }
   
   ```

2. 自定义MethodIntercepteor（方法拦截器）

   ```java
   import net.sf.cglib.proxy.MethodInterceptor;
   import net.sf.cglib.proxy.MethodProxy;
   
   import java.lang.reflect.Method;
   
   /**
    * 自定义MethodInterceptor
    */
   public class DebugMethodInterceptor implements MethodInterceptor {
   
   
       /**
        * @param o           被代理的对象（需要增强的对象）
        * @param method      被拦截的方法（需要增强的方法）
        * @param args        方法入参
        * @param methodProxy 用于调用原始方法
        */
       @Override
       public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
           //调用方法之前，我们可以添加自己的操作
           System.out.println("before method " + method.getName());
           Object object = methodProxy.invokeSuper(o, args);
           //调用方法之后，我们同样可以添加自己的操作
           System.out.println("after method " + method.getName());
           return object;
       }
   
   }
   
   ```

3. 获取代理类

   ```java
   import net.sf.cglib.proxy.Enhancer;
   
   public class CglibProxyFactory {
   
       public static Object getProxy(Class<?> clazz) {
           // 创建动态代理增强类
           Enhancer enhancer = new Enhancer();
           // 设置类加载器
           enhancer.setClassLoader(clazz.getClassLoader());
           // 设置被代理类
           enhancer.setSuperclass(clazz);
           // 设置方法拦截器
           enhancer.setCallback(new DebugMethodInterceptor());
           // 创建代理类
           return enhancer.create();
       }
   }
   ```

4. 实际使用

   ```java
   AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);
   aliSmsService.send("java");
   
   before method send
   send message:java
   after method send
   ```

#### JDK动态代理和CGLIB动态代理

- JDK 动态代理**只能代理实现了接口的类或者直接代理接口**，而 CGLIB 可以**代理未实现任何接口的类**。
- 另外， **CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用**，因此**不能代理声明为 final 类型的类和方法。**
  - 被代理类：AliSmsService。
    被代理的子类：由 CGLIB 自动生成的 AliSmsService 子类，这个子类包含了 DebugMethodInterceptor 的拦截逻辑。
- 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显

### 静态代理和动态代理的对比

- 灵活性：
  - 动态代理**更加灵活，不需要必须实现接口，可以直接代理实现类**，并且可以**不需要针对每个目标类都创建一个代理类。**
  - 另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
- JVM 层面：静态代理在**编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件**。而动态代理是在**运行时动态生成类字节码，并加载到 JVM 中的。**

### --------注解---------

### 什么是注解？解析方法有哪些？

Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，**主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。**

注解只有被解析之后才会生效，常见的解析方法有两种：

- **编译期直接扫描**：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。

### Java注解的原理

- **注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。**
- 我**们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。**通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池

### Java注解的作用域

注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：

1. 类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。
2. 方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。
3. 字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。

### --------SPI----------

### 什么是SPI

SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。**SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦**，能够提升程序的扩展性、可维护性。**修改或者替换服务实现并不需要修改调用方。**

### SPI和API的区别

API（Application Programming Interface）

- 当实现方提供了接口和实现，我们可以通过**调用实现方的接口从而拥有实现方给我们提供的能力**，这就是 API。这种情况下，**接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。**
- 当接口存在于调用方这边时，这就是 **SPI ** 。**由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。**

### SPI的优缺点

通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：

- **需要遍历加载所有的实现类，**不能做到按需加载，这样**效率还是相对较低**的。
- 当多个 ServiceLoader 同时 load 时，**会有并发问题。**

### -序列化和反序列化-

### 什么是序列化与反序列化

- 序列化：将数据结构或**对象转换成二进制字节流**的过程
- 反序列化：将在序列化过程中所生成的**二进制字节流转换成数据结构或者对象**的过程

对于 **Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，**但是在 C**++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。**

序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。

- 对象在**进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，**接收到序列化的对象之后需要再进行反序列化；
- 将**对象存储到文件之前需要进行序列化**，将对象从文件中读取出来需要进行反序列化；
- 将**对象存储到数据库（如 Redis）之前需要用到序列化**，将对象从缓存数据库中读取出来需要反序列化；
- 将**对象存储到内存之前需要进行序列化**，从内存中读取出来之后需要进行反序列化。

#### 序列化协议对应四层模型哪一层？

- OSI 七层协议模型中，**表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流**。反过来的话，就是将二进制流转换成应用层的用户数据。就对应的是序列化和反序列化。
- 因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议**应用层的一部分**

### 如果有些字段不想进行序列化怎么办？

对于不想进行序列化的变量，使用 transient 关键字修饰。

- transient 关键字的作用是：**阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。**

关于 transient 还有几点注意：

- transien**t 只能修饰变量**，不能修饰类和方法。
- transient 修饰的变量，**在反序列化后变量值将会被置成类型的默认值**。例如，如果是修饰 int 类型，那么反序列后结果就是 0。
- **static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化**

### 常见的序列化协议？

- JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。

  - 问题

    - **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。
    - 性能差：相比于其他序列化框架性能更低，主要原因是**序列化之后的字节数组体积较大，导致传输成本加大。**
    - 存在安全问题：序列化和反序列化本身并不存在问题。**但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码**

  - ```java
    @AllArgsConstructor
    @NoArgsConstructor
    @Getter
    @Builder
    @ToString
    public class RpcRequest implements Serializable {
        private static final long serialVersionUID = 1905122041950251207L;
        private String requestId;
        private String interfaceName;
        private String methodName;
        private Object[] parameters;
        private Class<?>[] paramTypes;
        private RpcMessageTypeEnum rpcMessageTypeEnum;
    }
    ```

  - serialVersionUID 有什么作用？
    序列化号 serialVersionUID 属于**版本控制的作用**。反序列化时，**会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。**强烈推荐每个序列化类都**手动指定**其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。

  - serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？

    - **static 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。*
      然而，serialVersionUID 是一个特例，**serialVersionUID 的序列化做了特殊处理**。**
      **当一个对象被序列化时，**serialVersionUID 会被写入到序列化的二进制流中；
      **在**反序列化时，也会解析它并做一致性判断**，以此来验证序列化对象的版本一致性。
      如果两者不匹配，反序列化过程将抛出 InvalidClassException，因为这通常意味着序列化的类的定义已经发生了更改，可能不再兼容

- 比较常用的序列化协议有 **Hessian、Kryo、Protobuf、ProtoStuff**，这些都是**基于二进制的序**列化协议。

  1. Hessian

     Hessian 是一个**轻量级的，自定义描述的二进制 RPC 协议**。Hessian 是一个**比较老的序列化**实现了，并且同样也是**跨语言**的。

     Dubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多

  2. **Kryo**

     Kryo 是一个高性能的序列化/反序列化工具，由于其**变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。**
     另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。

  3. Protobuf

     Protobuf 出自于 Google，**性能还比较优秀，也支持多种语言，同时还是跨平台的**。就是在**使用中过于繁琐，**因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf **没有序列化漏洞的风险。**

  4. ProtoStuff

     protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。

- 如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合.proto 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀。

- 像 **JSON 和 XML 这种属于文本类序列化方式**。虽然可读性比较好，但是**性能较差**，一般不会选择

### 怎么把一个对象从一个jvm转移到另一个jvm

1. **使用序列化和反序列化：**将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。
2. **使用消息传递机制**：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。
3. **使用远程方法调用（RPC）：**可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。
4. **使用共享数据库或缓存：**将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景

### 将对象转为二进制字节流具体怎么实现？

**序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的处理和解析协议，例**如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 class 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象。

**在Java中通过序列化对象流来完成序列化和反序列化：**

- ObjectOutputStream：通过writeObject(）方法做序列化操作。
- ObjectInputStrean：通过readObject()方法做反序列化操作。

**只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！**

#### 实现对象序列化

1. 让类实现Serailizable接口

   ```java
   import java.io.Serializable;
   public class MyClass implements Serializable {
   // class code
   }
   ```

2. 创建输出流并写入对象

   ```java
   import java.io.FileOutputStream;
   import java.io.ObjectOutputStream;
   MyClass obj = new MyClass();
   try {
   FileOutputStream fileOut = new FileOutputStream("object.ser");
   ObjectOutputStream out = new ObjectOutputStream(fileOut);
   out.writeObject(obj);
   out.close();
   fileOut.close();
   } catch (IOException e) {
   e.printStackTrace();
   }
   ```

#### 实现对象反序列化

1. 创建输入流并读取对象

   ```java
   import java.io.FileInputStream;
   import java.io.ObjectInputStream;
   MyClass newObj = null;
   try {
   FileInputStream fileIn = new FileInputStream("object.ser");
   ObjectInputStream in = new ObjectInputStream(fileIn);
   newObj = (MyClass) in.readObject();
   in.close();
   fileIn.close();
   } catch (IOException | ClassNotFoundException e) {
   e.printStackTrace();
   }
   ```

   通过以上步骤，对象obj会被序列化并写入到文件"object.ser"中，然后通过反序列化操作，从文件中读取字节流并恢复为对象newObj。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了Serializable接口，并且所有成员变量都是Serializable的才能被正确序列化。

### ---------IO----------

### Java IO流了解吗

- IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。
- Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。
  - InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
  - OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流

### IO流为什么要分为字节流和字符流？

- **字符流是由 Java 虚拟机将字节转换得到的**，这个过程还算是比较**耗时；**
- 如果我们**不知道编码类型的话，使用字节流的过程中很容易出现乱码问题**。

### -------语法糖-------

### 什么是语法糖

语法糖（Syntactic sugar） 代指的是**编程语言为了方便程序员开发程序而设计的一种特殊语法**，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读

JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，**需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法。**这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。

### Java中有哪些常见的语法糖

Java 中最常用的语法糖主要有**泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式**等。

------

### -------新特性-------

### Java1.8

**Java 8引入了Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等**。Stream API不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理

```java
案例1：过滤并收集满足条件的元素
问题场景：从一个列表中筛选出所有长度大于3的字符串，并收集到一个新的列表中。
没有Stream API的做法：
List<String> originalList = Arrays.asList("apple", "fig", "banana", "kiwi");
List<String> filteredList = new ArrayList<>();
for (String item : originalList) {
if (item.length() > 3) {
filteredList.add(item);
}
}
这段代码需要显式地创建一个新的ArrayList，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中。
使用Stream API的做法：
List<String> originalList = Arrays.asList("apple", "fig", "banana", "kiwi");
List<String> filteredList = originalList.stream()
.filter(s -> s.length() > 3)
.collect(Collectors.toList());
这里，我们直接在原始列表上调用.stream()方法创建了一个流，使用.filter()中间操作筛选出长度大于3的字符串，最后使用.collect(Collectors.toList())终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然。
```

```java
案例2：计算列表中所有数字的总和
问题场景：计算一个数字列表中所有元素的总和。
没有Stream API的做法：
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = 0;
for (Integer number : numbers) {
sum += number;
}
这个传统的for-each循环遍历列表中的每一个元素，累加它们的值来计算总和。
使用Stream API的做法：
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
.mapToInt(Integer::intValue)
.sum();
通过Stream API，我们可以先使用.mapToInt()将Integer流转换为IntStream（这是为了高效处理基本类型），然后直接调用.sum()方法来计算总和，极大地简化了代码。
```

### Stream流的并行API是什么？

**是 ParallelStream。**
并行流（ParallelStream）就是**将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象**，底层是使用通用的 fork/join 池来实现，即将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果

Stream串行流与并行流的主要区别：

![image-20241009113349757](D:\2024\Notes\Typora\八股\Java.assets\image-20241009113349757.png)

对CPU密集型的任务来说，并行流使用ForkJoinPool线程池，为每个CPU分配一个任务，这是非常有效率的，但是如果任务不是CPU密集的，而是I/O密集的，并且任务数相对线程数比较大，那么直接用ParallelStream并不是很好的选择

### ------设计模式------

### volatile和sychronized如何实现单例模式

```java
public class SingleTon {
// volatile 关键字修饰变量 防止指令重排序
private static volatile SingleTon instance = null;
private SingleTon(){}
public static  SingleTon getInstance(){
if(instance == null){
//同步代码块 只有在第一次获取对象的时候会执行到 ，第二次及以后访问时 instance变量均非null故不会往下执行了 直接返回啦
synchronized(SingleTon.class){
if(instance == null){
instance = new SingleTon();
}
}
}
return instance;
}
}
```

正确的双重检查锁定模式需要需要使用 volatile。volatile主要包含两个功能。

- 保证可见性。使用 volatile 定义的变量，将会保证对所有线程的可见性。
- 禁止指令重排序优化。

由于 volatile 禁止对象创建时指令之间重排序，**所以其他线程不会访问到一个未初始化的对象，从而保证安全性。**

### 代理模式和适配器模式的区别

1. 目的不同：代理模式主要关注**控制对对象的访问，**而适配器模式则**用于接口转换**，使不兼容的类能够一起工作。
2. 结构不同：**代理模式一般包含抽象主题、真实主题和代理三个角色**，**适配器模式包含目标接口、适配器和被适配者三个角色。**
3. 应用场景不同：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作

## 集合

### ------集合概述------

### 数组与集合的区别？用过哪些集合类？

#### 数组和集合的区别：

- 数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。
- 数组可以包含基本数据类型和对象，而集合只能包含对象。
- 数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。

#### 用过哪些集合类？

- ArrayList： 动态数组，实现了List接口，支持动态增长。
- LinkedList： 双向链表，也实现了List接口，支持快速的插入和删除操作。
- HashMap： 基于哈希表的Map实现，存储键值对，通过键快速查找值。
- HashSet： 基于HashMap实现的Set集合，用于存储唯一元素。
- TreeMap： 基于红黑树实现的有序Map集合，可以按照键的顺序进行排序。
- LinkedHashMap： 基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序。
- PriorityQueue： 优先队列，可以按照比较器或元素的自然顺序进行排序

### Java集合概览

Java 集合，也叫作容器，主要是由两大接口派生而来：

- 一个是 Collection接口，主要用于**存放单一元素；**
  - 下面又有三个主要的子接口：List、Set 、 Queue。
- 另一个是 Map 接口，主要用于存放键值对。

### Collections和Collection区别

- **Collection是Java集合框架中的一个接口，它是所有集合类的基础接口。**它定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。Collection接口有许多实现类，如List、Set和Queue等。
- **Collections（注意有一个s）是Java提供的一个工具类，**位于java.util包中。它提供了一系列静态方法，用于对集合进行操作和算法。Collections类中的方法包括排序、查找、替换、反转、随机化等等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。

### List，Set，Queue，Map四者的区别？

- List(对付顺序的好帮手): 存储的元素是**有序的、可重复的。**
- Set(注重独一无二的性质): 存储的元素**不可重复的。**
- Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，**存储的元素是有序的、可重复的。**
- Map(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，**key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。**

### 集合框架底层数据结构总结

- List
  
  List是有序的Collection，使用此接口能够精确的控制每个元素的插入位置，用户能根据索引访问List中元素。常用的实现List的类有LinkedList，ArrayList，Vector，Stack。
  
  - ArrayList：ArrayList是容量可变的**非线程安全列表**，其底层使用数组实现。**当几何扩容时，会创建更大的数组，并把原数组复制到新数组。**ArrayList支持对元素的快速随机访问，但插入与删除速度很慢
  - Vector：Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。
  - LinkedList：**线程不安全**。**双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。LinkedList本质是一个双向链表**，与ArrayList相比，，其插入和删除速度更快，但随机访问速度更慢。
  
  **Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。**除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。
  
  而 **LinkedList 进行节点插入、删除却要高效得多**，但是随机访问性能则要比动态数组慢
  
- Set
  
  不允许存在重复的元素，与List不同，set中的元素是无序的。常用的实现有HashSet，LinkedHashSet和TreeSet。
  
  - **HashSet(无序，唯一):** **基于 HashMap 实现的，底层采用 HashMap 来保存元素。**
    - LinkedHashSet: **LinkedHashSet 是 HashSet 的子类，其内部是通过 LinkedHashMap 来实现的。**
  - **TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)。**
  
- Queue
  - PriorityQueue: Object[] 数组来实现小顶堆。详细可以查看：PriorityQueue 源码分析。
  - DelayQueue:PriorityQueue。详细可以查看：DelayQueue 源码分析。
  - ArrayDeque: 可扩容动态双向数组。
  
- Map
  
  Map 是一个键值对集合，存储键、值和之间的映射。Key 无序，唯一；value 不要求有序，允许重复。Map 没有继承于 Collection 接口，从 Map 集合中检索元素时，只要给出键对象，就会返回对应的值对象。主要实现有TreeMap、HashMap、HashTable、LinkedHashMap、ConcurrentHashMap
  
  - **HashMap**：**JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）**。**JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）**（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。详细可以查看：HashMap 源码分析。
    - **LinkedHashMap：LinkedHashMap 继承自 HashMap，**所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。**另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，**使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：LinkedHashMap 源码分析
    - **Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则主要为解决哈希冲突而存在的。**
    - ConcurrentHashMap：**Node数组+链表+红黑树**实现，**线程安全的（jdk1.8以前Segment锁，1.8以后volatile + CAS 或者 synchronized）**
  - **TreeMap：红黑树（自平衡的排序二叉树）**

### 如何选用集合

- 我们**需要根据键值获取到元素值**时就选用 Map 接口下的集合
  - 需要**排序时选择 TreeMap**,**不需要排序时就选择 HashMap**
  - 需**要保证线程安全就选用 ConcurrentHashMap。**
- 我们**只需要存放元素值时，就选择实现Collection 接口的集合**，
  - 需要**保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，**
  - **不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，**
  - 然后再根据实现这些接口的集合的特点来选用

### Java中线程安全的集合

- 在 java.util 包中的线程安全的类主要 2 个，其他都是非线程安全的。
  - **Vector：线程安全的动态数组，**其内部方法基本都经过**synchronized修饰，**如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可**以根据需要自动的增加容量**，当数组已满时，会创建新的数组，并拷贝原有数组数据。
  - **Hashtable：线程安全的哈希表**，HashTable 的加锁方法是给每个方法加上 synchronized 关键字，这样锁住的是整个 Table 对象，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用，如**果要保证线程安全的哈希表，可以用ConcurrentHashMap。**
- java.util.concurrent 包提供的都是线程安全的集合：
- 并发Map：
  - **ConcurrentHashMap：**它与 HashTable 的主要区别是二者加锁粒度的不同，在JDK1.7，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment 含有整个 table 的一部分，这样不同分段之间的并发操作就互不影响。**在JDK 1.8 ，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率**。对于put操作，如果Key对应的数组元素为null，则通过CAS操作（Compare and Swap）将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为红黑树，从而提高寻址效率。
  - **ConcurrentSkipListMap：**实现了一个基于SkipList（跳表）算法的可排序的并发集合，SkipList是一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的“跳跃”链接来实现高效查找。
- 并发Set：
  - **ConcurrentSkipListSet：**是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。
  - **CopyOnWriteArraySet：**是线程安全的Set实现，它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过“散列表”实现的，而CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。
- 并发List：
  - **CopyOnWriteArrayList：**它是 ArrayList 的线程安全的变体，其中所有写操作（add，set等）都通过对底层数组进行全新复制来实现，允许存储 null 元素。即当对象进行写操作时，使用了Lock锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；若进行的读操作，则直接返回结果，操作过程中不需要进行同步。
- 并发 Queue：
  - **ConcurrentLinkedQueue**：是一个适用于高并发场景下的队列，它通过无锁的方式(CAS)，实现了高并发状态下的高性能。通常，ConcurrentLinkedQueue 的性能要好于 BlockingQueue 。
  - **BlockingQueue：**与 ConcurrentLinkedQueue 的使用场景不同，BlockingQueue 的主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。BlockingQueue 提供一种读写阻塞等待的机制，即如果消费者速度较快，则 BlockingQueue 则可能被清空，此时消费线程再试图从 BlockingQueue 读取数据时就会被阻塞。反之，如果生产线程较快，则 BlockingQueue 可能会被装满，此时，生产线程再试图向 BlockingQueue 队列装入数据时，便会被阻塞等待。
- 并发 Deque：
  - **LinkedBlockingDeque**：是一个线程安全的双端队列实现。它的内部使用链表结构，每一个节点都维护了一个前驱节点和一个后驱节点。LinkedBlockingDeque 没有进行读写锁的分离，因此同一时间只能有一个线程对其进行操作
  - **ConcurrentLinkedDeque**：ConcurrentLinkedDeque是一种基于链接节点的无限并发链表。可以安全地并发执行插入、删除和访问操作。当许多线程同时访问一个公共集合时，ConcurrentLinkedDeque是一个合适的选择

### --------List----------

### ArrayList扩容机制

ArrayList在添加元素时，如果当前元素个数已经达到了内部数组的容量上限，就会触发扩容操作。ArrayList的扩容操作主要包括以下几个步骤：

- **计算新的容量**：一般情况下，新的容量会扩大为原容量的1.5倍（在JDK 10之后，扩容策略做了调整），然后检查是否超过了最大容量限制。
- **创建新的数组**：根据计算得到的新容量，创建一个新的更大的数组。
- 将**元素复制**：将原来数组中的元素逐个复制到新数组中。
- **更新引用：**将ArrayList内部指向原数组的引用指向新数组。
- **完成扩容**：扩容完成后，可以继续添加新元素。

ArrayList的扩容操作涉及到数组的复制和内存的重新分配，所以在频繁添加大量元素时，扩容操作可能会影响性能。为了减少扩容带来的性能损耗，可以在初始化ArrayList时预分配足够大的容量，避免频繁触发扩容操作。
**之所以扩容是 1.5 倍，是因为 1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。**

```java
// 新容量计算
int newCapacity = oldCapacity + (oldCapacity >> 1);
```

### ArrayList和Array的区别？

|          |                     ArrayLIst                      |                            Array                             |
| :------: | :------------------------------------------------: | :----------------------------------------------------------: |
| 内部实现 |                    基于动态数组                    |                           静态数组                           |
|   泛型   |                        允许                        |                            不允许                            |
|   对象   | 只能存储对象，对于基本类型数据，需要使用对应包装类 |            既可以存储对象，也可以存储基本类型数据            |
|   操作   |         支持插入删除遍历等、提供丰富的API          | 固定长度数组，只能按照下标访问元素，不具备动态添加、删除元素的能力 |
|   大小   |                   不需要指定大小                   |                         需要指定大小                         |

### ArrayList和Vector区别

Vector是古老实现类，线程安全。ArrayList线程不安全

### Vector和Stack区别

Stack 继承自 Vector，是一个后进先出的栈，而 Vector 是一个列表。
随着 Java 并发编程的发展，Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 ConcurrentHashMap、CopyOnWriteArrayList 等）或者手动实现线程安全的方法来提供安全的多线程操作支持

### ArrayList可以添加Null值吗

ArrayList 中可以存储任何类型的对象，包括 null 值。不过，不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。

### ArrayList插入和删除元素的时间复杂度

对于插入：

- **头部插入**：由于需要将所有元素都依次向后移动一个位置，**因此时间复杂度是 O(n)。**
- 尾部插入：当 ArrayList 的容量**未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，**因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。
- 指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程**需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。**

对于删除：

- **头部删除**：由于需要将所有元素依次向前移动一个位置，**因此时间复杂度是 O(n)。**
- **尾部删除**：当删除的元素位于列表末尾时，**时间复杂度为 O(1)。**
- **指定位置删除**：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，**因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。**

### LinkedList插入和删除元素的时间复杂度

- 头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因**此时间复杂度为 O(1)。**
- 尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此**时间复杂度为 O(1)。**
- 指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要遍历平均 n/2 个元素，**时间复杂度为 O(n)。**

### LinkedList为什么不能实现RandomAccess接口？

**RandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问**（**即可以通过索引快速访问元素**）。由于 LinkedList 底层数据结构**是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问**，所以不能实现 RandomAccess 接口。

### ArrayList和LinkedList区别？

|                                |            Arraylist             |                         linkedlist                          |
| :----------------------------: | :------------------------------: | :---------------------------------------------------------: |
|            线程安全            |      不同步，不保证线程安全      |                   不同步，不保证线程安全                    |
|          底层数据结构          |            Object数组            |                          双向链表                           |
| 插入和删除是否受元素位置的影响 |       采用数组存储，受影响       |                    采用链表存储，受影响                     |
|      是否支持快速随机访问      |               支持               |                           不支持                            |
|          内存空间占用          | list列表结尾会预留一定的容量空间 | 每一个元素都需要消耗比 ArrayList 更多的空间，存放后继、前驱 |

### ArrayList和LinkedList的区别，哪个集合是线程安全的？

ArrayList和LinkedList都是Java中常见的集合类，它们都实现了List接口。

- **底层数据结构不同**：ArrayList使用数组实现，通过索引进行快速访问元素。LinkedList使用链表实现，通过节点之间的指针进行元素的访问和操作。
- **插入和删除操作的效率不同：**ArrayList在尾部的插入和删除操作效率较高，但在中间或开头的插入和删除操作效率较低，需要移动元素。LinkedList在任意位置的插入和删除操作效率都比较高，因为只需要调整节点之间的指针，但是LinkedList是不支持随机访问的，所以除了头结点外插入和删除的时间复杂度都是0(n)，效率也不是很高所以LinkedList基本没人用。
- **随机访问的效率不同**：ArrayList支持通过索引进行快速随机访问，时间复杂度为O(1)。LinkedList需要从头或尾开始遍历链表，时间复杂度为O(n)。
- **空间占用：**ArrayList在创建时需要分配一段连续的内存空间，因此会占用较大的空间。LinkedList每个节点只需要存储元素和指针，因此相对较小。
- **使用场景**：ArrayList适用于频繁随机访问和尾部的插入删除操作，而LinkedList适用于频繁的中间插入删除操作和不需要随机访问的场景。
- 线程安全：这两个集合都不是线程安全的，Vector是线程安全的

### ArrayList线程安全吗？把ArrayList变成线程安全的方法有什么？

不是线程安全的，ArrayList变成线程安全的方式有：

1. **使用Collections类的synchronizedList**方法将ArrayList包装成线程安全的List：

   `List<String> synchronizedList = Collections.synchronizedList(arrayList);`

2. **使用CopyOnWriteArrayList类**代替ArrayList，它是一个线程安全的List实现：

   `CopyOnWriteArrayList<String> copyOnWriteArrayList = new CopyOnWriteArrayList<>(arrayList);`

3. **使用Vector类**代替ArrayList，Vector是线程安全的List实现：

   `Vector<String> vector = new Vector<>(arrayList);`

### 为什么ArrayList不是线程安全的?具体来说是哪里不安全？

ArrayList add增加元素的过程如下：

1. 判断数组需不需要扩容，如果需要的话，调用grow方法进行扩容；
2. 将数组的size位置设置值（因为数组的下标是从0开始的）；
3. 将当前集合的大小加1

在高并发添加数据下，ArrayList会暴露三个问题;

1. **部分值为null：**由于线程1和线程2都设置了数组的第9个位置，但只有一个线程的设置值会保留下来，另一个线程的设置会被覆盖。
   然后，两个线程都执行了 size++ 操作，使得 size 成功从9增加到10。
   但是，由于两个线程都没有检查 size 是否已经等于 capacity，并且没有扩容，导致数组的下一个位置（即索引为9的位置）为 null。
2. **索引越界异常：**线程1走到扩容那里发现当前size是9，数组容量是10不用扩容，cpu让出执行权，线程2也发现不用扩容，这时候数组的容量就是10，而线程1 set完之后size++，这时候线程2再进来size就是10，数组的大小只有10，而你要设置下标索引为10的就会越界（数组的下标索引从0开始）；
3. **size与我们add的数量不符：**这个基本上每次都会发生，这个理解起来也很简单，因为size++本身就不是原子操作，可以分为三步：获取size的值，将size的值加1，将新的size值覆盖掉原来的，线程1和线程2拿到一样的size值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与我们add的数量保持一致的；



### --------Set----------

### Set集合有什么特点？如何实现key无重复的？

set集合特点：Set集合中的元素是唯一的，不会出现重复的元素。
set实现原理：Set集合通过内部的数据结构（如哈希表、红黑树等）来实现key的无重复。当向Set集合中插入元素时，会先根据元素的hashCode值来确定元素的存储位置，然后再通过equals方法来判断是否已经存在相同的元素，如果存在则不会再次插入，保证了元素的唯一性。

### 有序的Set是什么？记录插入顺序的集合是什么？

**有序的 Set 是TreeSet和LinkedHashSet。**TreeSet是基于红黑树实现，保证元素的自然顺序。LinkedHashSet是基于双重链表和哈希表的结合来实现元素的有序存储，保证元素添加的自然顺序
**记录插入顺序的集合通常指的是LinkedHashSet****，它不仅保证元素的唯一性，还可以保持元素的插入顺序。当需要在Set集合中记录元素的插入顺序时，可以选择使用LinkedHashSet来实现。

### Comparable和Comparator的区别

Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：

- Comparable 接口实际上是出自java.lang包 **它有一个 compareTo(Object obj)方法用来排序**
- Comparator接口实际上是出自 java.util 包**它有一个compare(Object obj1, Object obj2)方法用来排序**

当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort()

#### 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？

可以使用Comparable接口来实现按照分数排序，再按照学号排序。首先在学生类中实现Comparable接口，并重写compareTo方法，然后在compareTo方法中实现按照分数排序和按照学号排序的逻辑。

```java
public class Student implements Comparable<Student> {
private int id;
private int score;
// 构造方法和其他属性、方法省略
@Override
public int compareTo(Student other) {
if (this.score != other.score) {
return Integer.compare(other.score, this.score); // 按照分数降序排序
} else {
return Integer.compare(this.id, other.id); // 如果分数相同，则按照学号升序排序
}
}
}
```

然后在需要对学生列表进行排序的地方，使用Collections.sort()方法对学生列表进行排序即可：

```java
List<Student> students = new ArrayList<>();
// 添加学生对象到列表中
Collections.sort(students);
```

### 比较HashSet、LinkedHashSet和TreeSet三者异同

- HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证**元素唯一，并且都不是线程安全的。**
- HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。
  - HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。
  - **LinkedHashSet 的底层数据结构是链表和哈希表**，元素的插入和取出顺序满足 FIFO。
  - **TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。**
- 底层数据结构不同又导致这三者的应用场景不同。
  - HashSet 用于**不需要保证元素插入和取出顺序的场景，**
  - LinkedHashSet 用于保证**元素的插入和取出顺序满足 FIFO 的场景，**
  - TreeSet 用于支持对元素**自定义排序规则**的场景

### ------Queue--------

### Queue与Deque的区别

#### Queue

- Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。
- Queue 扩展了 Collection 的接口，根据 **因为容量问题而导致操作失败后处理方式的不同** 可以分为两类方法:
   一种在操作失败后**会抛出异常**，另一种则**会返回特殊值**
  - Queue 接口	抛出异常	返回特殊值
    插入队尾              add(E e)	   offer(E e)
    删除队首              remove()	  poll()
    查询队首元素      element()	peek()

#### Deque

- Deque 是双端队列，在队列的两端均可以插入或删除元素。
- Deque 扩展了 Queue 的接口, **增加了在队首和队尾进行插入和删除的方法，**根据失败后处理方式不同分为两类：
  - Deque 接口	         抛出异常	返回特殊值
    插入队首		addFirst(E e)	offerFirst(E e)
    插入队尾 		addLast(E e)	offerLast(E e)
    删除队首 		removeFirst()	pollFirst()
    删除队尾 		removeLast()	pollLast()
    查询队首元素	 getFirst()	      peekFirst()
    查询队尾元素 	getLast()	       peekLast()
- 事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈

### ArrayDeque与LinkedList的区别

ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？

- **ArrayDeque 是基于可变长的数组和双指针来实现**，而 LinkedList 则通过链表来实现。
- ArrayDeque 不支持存储 NULL 数据，**但 LinkedList 支持。**
- ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。
- ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。
  **虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。************

从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈

### PriorityQueue

PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在**于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。**

- PriorityQueue 利用**了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据**
- PriorityQueue 通过堆元素的上浮和下沉，**实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。**
- PriorityQueue 是**非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。**
- PriorityQueue 默认是**小顶堆**，**可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后**。

### BlockingQueue

- BlockingQueue （阻塞队列）是一个接口，继承自 Queue。BlockingQueue阻塞的原因是其支持**当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。**
- BlockingQueue 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。

实现类：

- ArrayBlockingQueue：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。
- LinkedBlockingQueue：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。
- PriorityBlockingQueue：支持优先级排序的无界阻塞队列。元素必须实现Comparable接口或者在构造函数中传入Comparator对象，并且不能插入 null 元素。
- SynchronousQueue：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，SynchronousQueue通常用于线程之间的直接传递数据。
  DelayQueue：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。
  ……
  日常开发中，这些队列使用的其实都不多，了解即可

### ArrayBlockingQueue和LinkedBlockingQueue的区别

- 底层实现：ArrayBlockingQueue 基于数组实现，而 LinkedBlockingQueue 基于链表实现。
- 是否有界：ArrayBlockingQueue 是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue 创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。
- **锁是否分离： ArrayBlockingQueue中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock，这样可以防止生产者和消费者线程之间的锁争夺。**
- 内存占用：ArrayBlockingQueue 需要提前分配数组内存，而 LinkedBlockingQueue 则是动态分配链表节点内存。这意味着，ArrayBlockingQueue 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而LinkedBlockingQueue 则是根据元素的增加而逐渐占用内存空间

### -------Map----------

### HashMap、Hashtable、ConcurrentHashMap

- HashMap线程不安全，效率高一点，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。**创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。**
- HashTable线程安全，效率低一点，其内部方法基本都经过synchronized修饰，不可以有null的key和value。默认初始容量为11，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。
- ConcurrentHashMap是Java中的一个线程安全的哈希表实现，它可以在多线程环境下并发地进行读写操作，而不需要像传统的HashTable那样在读写时加锁。ConcurrentHashMap的实现原理主要基于分段锁和CAS操作。它将整个哈希表分成了多Segment（段），每个Segment都类似于一个小的HashMap，它拥有自己的数组和一个独立的锁。在ConcurrentHashMap中，读操作不需要锁，可以直接对Segment进行读取，而写操作则只需要锁定对应的Segment，而不是整个哈希表，这样可以大大提高并发性能。

### HashMap和HashTable的区别

- 线程是否安全：
  -  HashMap 是**非线程安全的，**
  - HashTable是线程安全的，实现方式是Hashtable的所有公共方法均**采用synchronized关键字，当一个线程访问同步方法，另一个线程也访问的时候，就会陷入阻塞或者轮询的状态。**
  - （如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
- 效率： 
  - 因为线程安全的问题，**HashMap 要比 Hashtable 效率高一点。**
  - 另外**，Hashtable 基本被淘汰，不要在代码中使用它；**
- 对 Null key 和 Null value 的支持：
  -  HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个
  - Hashtable **不允许有 null 键和 null 值**，否则会抛出 NullPointerException。
- **初始容量大小和每次扩充容量大小的不同：**
  -  ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。
  - ② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。
- 底层数据结构： 
  - JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为**红黑树**（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。
  - Hashtable的底层数据结构主要是数组加上链表，数组是主体，链表是解决hash冲突存在的。
- 哈希函数的实现：
  - HashMap **对哈希值进行了高位和低位的混合扰动**处理以减少冲突，
  - 而 Hashtable **直接使用键的 hashCode() 值。**

### HashMap和HashSet区别

- **HashSet 底层就是基于 HashMap 实现的。**
  - HashMap						 			HashSet
    实现了 Map 接口							实现 Set 接口
    存储键值对 						  		 仅存储对象
    调用 put()向 map 中添加元素			调用 add()方法向 Set 中添加元素
    HashMap 使用**键（Key）**计算 hashcode	HashSet 用**成员对象**计算 hashcode 值，对两个对象							         来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性

### HashMap和TreeMap区别

- TreeMap 和HashMap 都继承自AbstractMap 
- 需要注意的是TreeMap还实现了**NavigableMap接口和SortedMap 接口。**相比于HashMap来说， TreeMap 主要多了**对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力**

  - NavigableMap接口提供了丰富的方法：

    - 定向搜索
    - 子集操作
    - 逆序视图
    - 边界操作

    这些方法都是基于红黑树数据结构的属性实现的，红黑树保持平衡状态，从而保证了搜索操作的时间复杂度为 O(log n)，这让 TreeMap 成为了处理有序集合搜索问题的强大工具。

  - 实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。


### HashSet如何检查重复？

- 当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功
- HashSet的add()方法只是简单的调用了HashMap的put()方法，并且判断了一下返回值以确保是否有重复元素。直接看一下HashSet中的源码。在JDK1.8中实际上无论HashSet中是否已经存在了某元素，HashSet都会直接插入，只是会在add()方法的返回值处告诉我们插入前是否存在相同元素。

### HashMap的底层实现

#### JDK1.8之前

- JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashcode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。
  - 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
- HashMap 中的扰动函数（hash 方法）是用来优化哈希值的分布。通过对原始的 hashCode() 进行额外处理，扰动函数可以减小由于糟糕的 hashCode() 实现导致的碰撞，从而提高数据的分布均匀性。

#### JDK1.8之后

- 相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，**当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。**
- TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

### HashMap为什么要用红黑树而不是二叉树？

- 平衡二叉树追求的是一种 “完全平衡” 状态：**任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的**。这个要求实在是太严了，导致每次进行插入/删除节点的时候，**几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，**使之再次成为一颗符合要求的平衡树。
- 红黑树不追求这种完全平衡状态，而**是追求一种 “弱平衡” 状态**：整个树最长路径不会超过最短路径的 2 倍。**优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。**与平衡树不同的是**，红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整**，这也是我们为什么大多数情况下使用红黑树的原因

### 重写HashMap的equal和hashcode方法需要注意什么？

HashMap使用Key对象的hashCode()和equals方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。
同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：
**如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。**
**如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true**

### 重写HashMap的equal方法不当会出现什么问题？

HashMap在比较元素时，**会先通过hashCode进行比较，相同的情况下再通过equals进行比较。**
**所以 equals相等的两个对象，hashCode一定相等。hashCode相等的两个对象，equals不一定相等（比如散列冲突的情况）**
重写了equals方法，不重写hashCode方法时，可能会出现equals方法返回为true，而hashCode方法却返回false，这样的一个后果会导致在hashmap等类中存储多个一模一样的对象，导致出现覆盖存储的数据的问题，这与hashmap只能有唯一的key的规范不符合

### hashmap的put过程介绍一下

1. 第一步：根据要添加的键的哈希码**计算在数组中的位置**（索引）。
2. 第二步**：检查该位置是否为空（**即没有键值对存在）
   1. 如果为空，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。将HashMap的修改次数（modCount）加1，以便在进行迭代时发现并发修改。
3. 第三步：如果该位置已经存在其他键值对，**检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同？**
   1. 如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。
4. 第四步：**如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键：**
   1. **如果键值对集合是链表结构，从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。**
      1. 如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。
      2. 如果没有找到相同的键，则将新的键值对添加到链表的头部。
   2. **如果键值对集合是红黑树结构，在红黑树中使用哈希码和equals()方法进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或达到红黑树末尾。**
      1. 如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。
      2. 如果没有找到相同的键，则将新的键值对添加到红黑树中。
5. 第五步：**检查链表长度是否达到阈值（默认为8）：**
   1. 如果链表长度超过阈值，且HashMap的数组长度大于等于64，则会将链表转换为红黑树，以提高查询效率。
6. 第六步：**检查负载因子是否超过阈值（默认为0.75）：**
   1. **如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作。**
7. 第七步：**扩容操作：**
   1. **创建一个新的两倍大小的数组。**
   2. 将旧数组中的键值对重新计算哈希码并分配到新数组中的位置。
   3. 更新HashMap的数组引用和阈值参数。
8. 第八步：**完成添加操作。**
   1. 此外，HashMap是非线程安全的，如果在多线程环境下使用，需要采取额外的同步措施或使用线程安全的ConcurrentHashMap。

### Hashmap的get过程

获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度

### hashmap调用get方法一定安全吗？

不是

1. 空指针异常

   **如果你尝试用 null 作为键调用 get 方法，而 HashMap 没有被初始化（即为 null），那么会抛出空指针异常**。不过，如果 HashMap 已经初始化，使用 null 作为键是允许的，因为 HashMap 支持 null 键

2. 线程安全

   HashMap 本身不是线程安全**的。如果在多线程环境中，没有适当的同步措施，同时对 HashMap 进行读写操作可能会导致不可预测的行**为。例如，在一个线程中调用 get 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 ConcurrentModificationException。如果需要在多线程环境中使用类似 HashMap 的数据结构，可以考虑使用 ConcurrentHashMap。

### hashmap一般用什么做key？为啥String适合做key？

用 string 做 key，因为 String对象是不可变的，一旦创建就不能被修改，这确保了Key的稳定性。如果Key是可变的，可能会导致hashCode和equals方法的不一致，进而影响HashMap的正确性。

### HashMap的长度为什么是2的幂次方

1. **位运算效率更高：**位运算(&)比取余运算(%)更高效。当长度为 2 的幂次方时，hash % length 等价于 hash & (length - 1)。
2. **可以更好地保证哈希值的均匀分布：**扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。
3. 扩容机制变得简单和高效：**扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。**

### 往hashmap存20个元素，会扩容几次？

当插入 20 个元素时，HashMap 的扩容过程如下：
初始容量：16
插入第 1 到第 12 个元素时，不需要扩容。
插入第 13 个元素时，达到负载因子限制，需要扩容。此时，HashMap 的容量从 16 扩容到 32。
扩容后的容量：32
插入第 14 到第 24 个元素时，不需要扩容。
**因此，总共会进行一次扩容**

### 说说hashmap的负载因子

HashMap 负载因子 loadFactor 的默认值是 0.75，当 HashMap 中的元素个数超过了容量的 75% 时，就会进行扩容。
默认负载因子为 0.75，是因为它提供了空间和时间复杂度之间的良好平衡。
**负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡**。

### HashMap多线程操作导致死循环问题

- 这是由于当一个桶位中有多个元素需要进行扩容时，**多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表**，进而使得查询元素的操作陷入死循环无法结束。
- JDK1.8 版本的 HashMap **采用了尾插法**而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。**但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在数据覆盖的问题**。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。并发环境下，推荐使用 ConcurrentHashMap 。

### HashMap为什么线程不安全

1. JDK1.7 及之前版本**，在多线程环境下，HashMap 扩容时会造成死循环和数据丢失的问题。**
2. JDK 1.8 后，在 HashMap 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。**多个线程对 HashMap 的 put 操作会导致线程不安全**，具体来说会有**数据覆盖的风险。**
   1. 由于时间片调度和哈希冲突，线程1在未检测到线程2已插入的情况下覆盖了线程2的数据。
   2. 由于时间片调度和竞态条件，两个线程在更新 size 时导致值计算不正确，使得尽管两次 put 操作都执行了，但实际上size只增加了

保证线程安全应该怎么做？

- 多线程环境可以使用Collections.synchronizedMap同步加锁的方式，还可以使用HashTable，但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。
- ConcurrentHashmap在JDK1.7和1.8的版本改动比较大，1.7使用Segment+HashEntry分段锁的方式实现，1.8则抛弃了Segment，改为使用CAS+synchronized+Node实现，同样也加入了红黑树，避免链表过长导致性能的问题

### HashMap常见的遍历方式

1. HashMap 遍历从大的方向来说，可分为以下 4 类：
   - **迭代器（Iterator）方式遍历；**	
   - **For Each 方式遍历；**
   - **Lambda 表达式遍历（JDK 1.8+）;**
   - **Streams API 遍历（JDK 1.8+）**。
2. 但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：
   1. 使用迭代器（Iterator）EntrySet 的方式进行遍历；
   2. 使用迭代器（Iterator）KeySet 的方式进行遍历；
   3. 使用 For Each EntrySet 的方式进行遍历；
   4. 使用 For Each KeySet 的方式进行遍历；
   5. 使用 Lambda 表达式的方式进行遍历；
   6. 使用 Streams API 单线程的方式进行遍历；
   7. 使用 Streams API 多线程的方式进行遍历。
3. 存在阻塞时 parallelStream 性能最高, 非阻塞时 parallelStream 性能最低 。

### ConcurrentHashMap和Hashtable的区别

1. 底层数据结构
   1. JDK1.7 的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，**数组+链表/红黑二叉树。**
   2. Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
2. 实现线程安全的方式
   1. ConcurrentHashMap
      1. 在 JDK1.7 的时候，**ConcurrentHashMap 对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据**（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
         1. ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 数组中的每个元素包含一个 HashEntry 数组，每个 HashEntry 数组属于链表结构。
         2. Segment 继承了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。
      2. 到了 JDK1.8 的时候，ConcurrentHashMap 已经摒弃了 Segment 的概念，而是直接**用 Node 数组+链表+红黑树的数据结构来实现，**并**发控制使用 synchronized 和 CAS 来操作**。（JDK1.6 以后 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；
         1. JDK1.8 的 ConcurrentHashMap 不再是 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。当冲突链表达到一定长度时，链表会转换成红黑树。
         2. TreeNode是存储红黑树节点，被TreeBin包装。TreeBin通过root属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 ConcurrentHashMap 中TreeBin通过waiter属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。
         3. Java 8 中，锁粒度更细，**synchronized 只锁定当前链表或红黑二叉树的首节点**，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。
      3. JDK 1.8 ConcurrentHashMap JDK 1.8 ConcurrentHashMap 主要通过 volatile + CAS 或者 synchronized 来实现的线程安全的。添加元素时首先会判断容器是否为空：
         1. 如果为空则使用 volatile 加 CAS 来初始化
            如果容器不为空，则根据存储的元素计算该位置是否为空。
         2. 如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；
            1. 如果根据存储的元素计算结果不为空，则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。
            2. 如果把上面的执行用一句话归纳的话，就相当于是ConcurrentHashMap通过对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。
               而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂度。
   2. Hashtable(同一把锁) **:使用 synchronized 来保证线程安全**，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。
3. （并发度：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。）

### 了解的哈希冲突解决办法有哪些？

- 链接法：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中。
- 开放寻址法：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。
- 再哈希法（Rehashing）：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。
- 哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率

### ConcurrentHashMap为什么key和value不能为null

ConcurrentHashMap

- 多线程环境下，存在一个线程操作该 ConcurrentHashMap 时，其他的线程将该 ConcurrentHashMap 修改的情况，所以无法通过 containsKey(key) 来判断否存在这个键值对，也就没办法解决二义性问题了。

HashMap

- 与此形成对比的是，HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 HashMap 修改的情况，所以可以通过 contains(key)来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。
- 也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。

### ConcurrentHashMap能保证复合操作的原子性吗？

复合操作是指由多个基本操作(如put、get、remove、containsKey等)组成的操作，例如先判断某个键是否存在containsKey(key)，然后根据结果进行插入或更新put(key, value)。**这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。**

ConcurrentHashMap **提供了一些原子性的复合操作**，如 putIfAbsent、compute、computeIfAbsent 、computeIfPresent、merge等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。

### ConcurrentHashMap已经用了synchronized，为什么还要用CAS

ConcurrentHashMap使用这两种手段来保证线程安全主要是一种权衡的考虑，在某些操作中使用synchronized，还是使用CAS，主要是根据锁竞争程度来判断的。

比如：在putVal中，如果计算出来的hash槽没有存放元素，那么就可以直接使用CAS来进行设置值，这是因为在设置元素的时候，因为hash值经过了各种扰动后，造成hash碰撞的几率较低，那么我们可以预测使用较少的自旋来完成具体的hash落槽操作。

当发生了hash碰撞的时候说明容量不够用了或者已经有大量线程访问了，因此这时候使用synchronized来处理hash碰撞比CAS效率要高，因为发生了hash碰撞大概率来说是线程竞争比较强烈

### ConcurrentHashMap用了悲观锁还是乐观锁?

悲观锁和乐观锁都有用到。
添加元素时首先会判断容器是否为空：

- 如果为空则使用 volatile 加 CAS （乐观锁） 来初始化。
- 如果容器不为空，则根据存储的元素计算该位置是否为空。
  - 如果根据存储的元素计算结果为空，则利用 CAS（乐观锁） 设置该节点；
  - 如果根据存储的元素计算结果不为空，则使用 synchronized（悲观锁） ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了

### --------Java集合使用注意事项----------

#### 集合判空

**判断所有集合内部的元素是否为空，使用 isEmpty() 方法，**而不是 size()==0 的方式。

- 这是因为 isEmpty() 方法的可读性更好，并且时间复杂度为 O(1)。
- 绝大部分我们使用的集合的 size() 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 java.util.concurrent 包下的某些集合（ConcurrentLinkedQueue、ConcurrentHashMap...）。

#### 集合转Map

 java.util.stream.Collectors 类的 **toMap() 方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。**

#### 集合遍历

**不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。**

##### 集合遍历的方法

1. 普通 for 循环： 可以使用带有索引的普通 for 循环来遍历 List。

   ```java
   List<String> list = new ArrayList<>();
   list.add("A");
   list.add("B");
   list.add("C");
   for (int i = 0; i < list.size(); i++) {
   String element = list.get(i);
   System.out.println(element);
   }
   ```

2. 增强 for 循环（for-each循环）： 用于循环访问数组或集合中的元素。

   ```java
   List<String> list = new ArrayList<>();
   list.add("A");
   list.add("B");
   list.add("C");
   for (String element : list) {
   System.out.println(element);
   }
   ```

3. Iterator 迭代器： 可以使用迭代器来遍历集合，特别适用于需要删除元素的情况

   ```java
   List<String> list = new ArrayList<>();
   list.add("A");
   list.add("B");
   list.add("C");
   Iterator<String> iterator = list.iterator();
   while(iterator.hasNext()) {
   String element = iterator.next();
   System.out.println(element);
   }
   ```

4. ListIterator 列表迭代器： ListIterator是迭代器的子类，可以双向访问列表并在迭代过程中修改元素

   ```java
   List<String> list = new ArrayList<>();
   list.add("A");
   list.add("B");
   list.add("C");
   ListIterator<String> listIterator= list.listIterator();
   while(listIterator.hasNext()) {
   String element = listIterator.next();
   System.out.println(element);
   }
   ```

5. 使用 forEach 方法： Java 8引入了 forEach 方法，可以对集合进行快速遍历。

   ```java
   List<String> list = new ArrayList<>();
   list.add("A");
   list.add("B");
   list.add("C");
   list.forEach(element -> System.out.println(element));
   ```

6. Stream API： Java 8的Stream API提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等

   ```java
   List<String> list = new ArrayList<>();
   list.add("A");
   list.add("B");
   list.add("C");
   list.stream().forEach(element -> System.out.println(element));
   ```

#### 集合去重

可以利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains() 进行遍历去重或者判断包含操作。

#### 集合转数组

使用集合转数组的方法**，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。**

#### 数组转集合

**使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法，** 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。

1. Arrays.asList()是泛型方法，传递的数组必须是对象数组，而不是基本类型。当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 List 的唯一元素就是这个数组，这也就解释了上面的代码。
2. 使用集合的修改方法: add()、remove()、clear()会抛出异常。

如何正确地将数组转换为ArrayList？

1、手动实现工具类

```java
//JDK1.5+
static <T> List<T> arrayToList(final T[] array) {
final List<T> l = new ArrayList<T>(array.length);
for (final T s : array) {
l.add(s);
}
return l;
}
Integer [] myArray = { 1, 2, 3 };
System.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList
```

2、最简便的方法

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
```

3、使用 Java8 的 Stream(推荐)

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
```

4、使用 Guava

```java
对于不可变集合，你可以使用ImmutableListopen in new window类及其of()open in new window与copyOf()open in new window工厂方法：（参数不能为空）
List<String> il = ImmutableList.of("string", "elements");  // from varargs
List<String> il = ImmutableList.copyOf(aStringArray);      // from array
对于可变集合，你可以使用Listsopen in new window类及其newArrayList()open in new window工厂方法：
List<String> l1 = Lists.newArrayList(anotherListOrCollection);    // from collection
List<String> l2 = Lists.newArrayList(aStringArray);               // from array
List<String> l3 = Lists.newArrayList("or", "string", "elements"); // from varargs
```

5、使用 Apache Commons Collections

```java
List<String> list = new ArrayList<String>();
CollectionUtils.addAll(list, str);
```

6、 使用 Java9 的 List.of()方法

```java
Integer[] array = {1, 2, 3};
List<Integer> list = List.of(array);
```

## 并发

### Java常见的并发容器总结

1. ConcurrentHashMap : 线程安全的 HashMap
2. CopyOnWriteArrayList : 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector。
3. ConcurrentLinkedQueue : 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。
4. BlockingQueue : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
5. ConcurrentSkipListMap : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找

#### CopyOnWriteArrayList

- 其中唯一的线程安全 List 实现就是 CopyOnWriteArrayList 。
- CopyOnWriteArrayList 线程安全的核心在于其采用了 写时复制（Copy-On-Write） 的策略
  - 当需要修改（ add，set、remove 等操作） CopyOnWriteArrayList 的内容时，不会直接修改原数组，而**是会先创建底层数组的副本，**对副本数组进行修改，**修改完之后再将修改后的数组赋值回去，**这样就可以保证写操作不会影响读操作了。
  
- CopyOnWriteArrayList底层也是通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。
  `private transient volatile Object[] array;`
  在写入操作时，加了一把互斥锁ReentrantLock以保证线程安全。

  ```java
  public boolean add(E e) {
  //获取锁
  final ReentrantLock lock = this.lock;
  //加锁
  lock.lock();
  try {
  //获取到当前List集合保存数据的数组
  Object[] elements = getArray();
  //获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值）
  int len = elements.length;
  //将当前数组拷贝一份的同时，让其长度加1
  Object[] newElements = Arrays.copyOf(elements, len + 1);
  //将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。
  newElements[len] = e;
  //替换引用，将数组的引用指向给新数组的地址
  setArray(newElements);
  return true;
  } finally {
  //释放锁
  lock.unlock();
  }
  }
  ```

  看到源码可以知道写入新元素时，首先会先将原来的数组拷贝一份并且让原来数组的长度+1后就得到了一个新数组，新数组里的元素和旧数组的元素一样并且长度比旧数组多一个长度，然后将新加入的元素放置都在新数组最后一个位置后，用新数组的地址替换掉老数组的地址就能得到最新的数据了。

  在我们执行替换地址操作之前，读取的是老数组的数据，数据是有效数据；执行替换地址操作之后，读取的是新数组的数据，同样也是有效数据，而且使用该方式能比读写都加锁要更加的效率。

  现在我们来看读操作，读是没有加锁的，所以读是一直都能读

  ```java
  public E get(int index) {
  return get(getArray(), index);
  }
  ```

#### ConcurrentLinkedQueue

Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，**其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，**在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 **阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。**

#### BlockingQueue

阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。**当队列容器已满，生产者线程会被阻塞**，直到队列未满；**当队列容器为空时，消费者线程会被阻塞**，直至队列非空时为止。

##### ArrayBlockingQueue

- ArrayBlockingQueue **一旦创建，容量不能改变**。其并发控制采用可重入锁 ReentrantLock ，不管是插入操作还是读取操作，都**需要获取到锁才能进行操作**。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。****
- ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，可以改

##### LinkedBlockingQueue

- LinkedBlockingQueue 底层基于**单向链表实现的阻塞队列，**可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE 。

##### PriorityBlockingQueue

- PriorityBlockingQueue **是一个支持优先级的无界阻塞队列。**默认情况下元素采用**自然顺序**进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素**排序规则**，或者初始化时通过构造器参数 Comparator 来指定排序规则。
- **PriorityBlockingQueue 并发控制采用的是可重入锁 ReentrantLock，队列为无界队列**（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue **只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容**）。
- 简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。

#### ConcurrentSkipListMap

- 跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。但对平衡树的插入和删除往往很可能导致平衡树**进行一次全局的调整**。而**对跳表的插入和删除只需要对整个数据结构的局部进行操作即可**
- 跳表是一种利用空间换时间的算法。
- 使用跳表实现 Map 和使用哈希算法实现 Map 的另外一个不同之处是：**哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。**因此**在对跳表进行遍历时，你会得到一个有序的结果**。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 ConcurrentSkipListMap。



### --------线程---------

### 什么是线程和进程

#### 进程

- 进程是程序的一次执行过程，**是系统运行程序的基本单位，**因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
- 在 Java 中，**当我们启动 main 函数时其实就是启动了一个 JVM 的进程**，而 **main 函数所在的线程就是这个进程中的主线程。**

#### 线程

- 线程与进程相似，**但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程**。
- 与进程不同的是同类的**多个线程共享进程的堆和方法区资源**，
- 但每个线程**有自己的程序计数器、虚拟机栈和本地方法栈**，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

### Java线程和操作系统线程的区别？

现在的 **Java 线程的本质其实就是操作系统的线程。**

- 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。
- 内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。
- 用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。

常见的线程模式：

- 一对一（一个用户线程对应一个内核线程）
  多对一（多个用户线程映射到一个内核线程）
  多对多（多个用户线程映射到多个内核线程）
- Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。Solaris 系统是一个特例

### 简述线程与进程的关系、区别和优缺点

一个进程中可以有多个线程，多个**线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源**，但是每个线程有自己的**程序计数器、虚拟机栈 和 本地方法栈。**

线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

#### 程序计数器为什么是私有

程序计数器私有主要**是为了线程切换后能恢复到正确的执行位置**

- 字节码解释器**通过改变程序计数器来依次读取指令**，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

- 在多线程的情况下，**程序计数器用于记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

  

- 如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

#### 虚拟机栈和本地方法栈为什么是私有的

为了保**证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

- 虚拟机栈： **每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息**。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务**，而**本地方法栈则为虚拟机使用到的 Native 方法服务**。 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

#### 什么是堆和方法区

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，**主要用于存放新创建的对象** (几乎所有对象都在这里分配内存)，**方法区**主要用于存放**已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**

### 如何创建线程

- **继承Thread类、实现Runnable接口、实现Callable接口、使用线程池、使用CompletableFuture类等**等，准确点来说，这些都属于是在 Java 代码中使用多线程的方法。

  1. 继承Thread类

     **重写run方法，run方法中定义了线程执行的具体任务，创建该类的实力以后，调用start方法启动线程**

     1. 优点：编写简单，如果需要访问当前线程，直接用this即可获得当前线程，无需使用Thread.currentThread ()方法
     2. 缺点：线程类已经继承了Thread类，所以不能在继承其他的父类。

  2. 实现Runnable接口

     如果一个类已经继承了其他类，就不能再继承Thread类，此时可以实现java.lang.Runnable接口。**实现Runnable接口需要重写run()方法，然后将此Runnable对象作为参数传递给Thread类的构造器，**创建Thread对象后调用其start()方法启动线程。

     1. 优点：**线程类只是实现了Runable接口，还可以继承其他的类。**在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想
     2. 缺点：**编程稍微复杂**，如果需要访问当前线程，必须使用Thread.currentThread()方法。

  3. 实现Callable接口

     Callable接口类似于Runnable，**但Callable的call()方法可以有返回值并且可以抛出异常。**要**执行Callable任务，需将它包装进一个FutureTask，**因为**Thread类的构造器只接受Runnable参数，而FutureTask实现了Runnable接口。**

     1. 优点：编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。
     2. 缺点：编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。

  4. 使用线程池

     1. 优点：增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂
     2. 缺点：线程池可以重用预先创建的线程，**避免了线程创建和销毁的开销**，显著提高了程序的性能。对于需要快速响应的并发请求，**线程池可以迅速提供线程来处理任务，减少等待时间**。并且，线程池能够**有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）**。通过合理配置线程池大小，可以最大化CPU利用率和系统吞吐量

  5. 使用CompletableFuture类

- 严格来说，Java 就只有一种方式可以创建线程，那就是通过new Thread().start()创建。不管是哪种方式，最终还是依赖于new Thread().start()。

### 说说线程的生命周期和状态？

![image-20241009212430907](D:\2024\Notes\Typora\八股\Java.assets\image-20241009212430907.png)

Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：

1. NEW: 初始状态，线程被创建出来但没有被调用 start() 。
2. RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。
3. BLOCKED：阻塞状态，需要等待锁释放。
4. WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
5. TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
6. TERMINATED：终止状态，表示该线程已经运行完毕。

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。

### 如何停止一个线程的运行？

1. **异常法停止：**线程**调用interrupt()方法后，在线程的run方法中判断当前对象的interrupted()状态，如果是中断状态则抛出异常，**达到中断线程的效果。
2. **在沉睡中停止：**先将线程**sleep，然后调用interrupt标记中断状态，interrupt会将阻塞状态的线程中断。会抛出中断异常，**达到停止线程的效果
3. **stop()暴力停止：**线程调用stop()方法会被暴力停止，方法已弃用，该方法会有不好的后果：强制让线程停止有可能使一些请理性的工作得不到完成。
4. **使用return停止线程：**调用interrupt标记为中断状态后，在run方法中判断当前线程状态，如果为中断状态则return，能达到停止线程的效果

### 调用interrupt是如何让线程抛出异常的？

**每个线程都一个与之关联的布尔属性来表示其中断状态，中**断状态的初始值为false，当一个线程被其它线程调用Thread.interrupt()方法中断时，会根据实际情况做出响应。

- 如果该线程正在**执行低级别的可中断方法**（如Thread.sleep()、Thread.join()或Object.wait()），**则会解除阻塞并抛出InterruptedException异常。**
- **否则Thread.interrupt()仅设置线程的中断状态，在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务。**

### 什么是线程上下文切换?

线程在执行过程中会有自己的**运行条件和状态**（也称上下文),当出现如下情况的时候，线程**会从占用 CPU 状态中退出。**

- **主动让出 CPU**，比如调用了 sleep(), wait() 等。
- **时间片用完**，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的**系统中断**，比如请求 IO，线程被阻塞。
- 被终止或结束运行

这其中前三种都会发生线程切换，线程切换意味着需要**保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文**。这就是所谓的 上下文切换。

每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下

### blocked和waiting有啥区别

- 触发条件:**线程进入BLOCKED状态通常是因为试图获取一个对象的锁（monitor lock），但该锁已经被另一个线程持有。**这通常发生在尝试进入synchronized块或方法时，如果锁已被占用，则线程将被阻塞直到锁可用。线**程进入WAITING状态是因为它正在等待另一个线程执行某些操作，**例如调用Object.wait()方法、Thread.join()方法或LockSupport.park()方法。在这种状态下，线程将不会消耗CPU资源，并且不会参与锁的竞争。
-  唤醒机制:**当一个线程被阻塞等待锁时，一旦锁被释放，线程将有机会重新尝试获取锁。**如果锁此时未被其他线程获取，那么线程可以从BLOCKED状态变为RUNNABLE状态。**线程在WAITING状态中需要被显式唤醒**。例如，如果线程调用了Object.wait()，那么它必须等待另一个线程调用同一对象上的Object.notify()或Object.notifyAll()方法才能被唤醒

###  wait状态下的进程如何进行恢复到running

- **等待的线程被其他线程对象唤醒，notify()和notifyAll()。**
- **如果线程没有获取到锁则会直接进入 Waiting 状态**，其实这种本质上它就是执行了 LockSupport.park() 方法进入了Waiting 状态，**那么解锁的时候会执行LockSupport.unpark(Thread)**，与上面park方法对应，给出许可证，解除等待状态

### notify和notifyall

同样是**唤醒等**待的线程，同样**最多只有一个线程能获得**锁，同样**不能控制哪个线程获得锁。**
区别在于：
notify：**唤醒一个线程，其他线程依然处于wait的等待唤醒状态**，如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断
notifyAll：**所有线程退出wait的状态，开始竞争锁，但只有一个线程能抢到**，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁

### notify选择哪个线程？

notify在源码的注释中说**到notify选择唤醒的线程是任意的，但是依赖于具体实现的jvm。JVM有很多实现**，比较流行的就是hotspot，hotspot对notofy()的实现并不是我们以为的随机唤醒,，而**是“先进先出”的顺序唤醒**

### Thread#sleep() 方法和 Object#wait() 方法对比

共同点：两者**都可以暂停线程的执行。**
区别：

- **sleep() 方法没有释放锁**，而 **wait() 方法释放了锁 。**
- wait() 通常被用**于线程间交互/通信**，sleep()通常被用于暂停执行。
- wait() 方法被调用后，线程**不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法**。sleep()方法执行完成后，线程会**自动苏醒，或**者也可以使用 wait(long timeout) **超时后线程会自动苏醒。**
- **sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法**。为什么这样设计呢？下一个问题就会聊到。

### 为什么wait()方法不定义在Thread中？

**wait() 是让获得对象锁的线程实现等待**，会**自动释放当前线程占有的对象锁**。
每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，**自然是要操作对应的对象（Object）**而非当前的线程（Thread）。

### 为什么 sleep()方法定义在 Thread中？

**让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁**

### 可以直接调用Thread类的run方法吗？

调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。

- new 一个 Thread，线程进入了新建状态。
- 调用 start()方法，会启动一个线程并使 线程进入了就绪状态，当分配到时间片后就可以开始运行了。
-  start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 
- 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

### ------多线程-------

并发：两个及两个以上的作业在同一 时间段内执行。
并行：两个及两个以上的作业在同一 时刻 执行。

同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
异步：调用在发出之后，不用等待返回结果，该调用直接返回

### 为什么使用多线程

- 线程间的切换和调度的成本远远小于进程。
- 多个线程可以同时运行，这减少了线程上下文切换的开销。
- 利用好多线程机制可以大大提高系统整体的并发能力以及性能
- 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率
- 多核时代多线程主要是为了提高进程利用多核 CPU 的

### 单核CPU支持Java多线程吗？

单核 CPU 是支持 Java 多线程的。操作系统通过时间片轮转的方式，将 CPU 的时间分配给不同的线程。尽管单核 CPU 一次只能执行一个任务，但通过快速在多个线程之间切换，可以让用户感觉多个任务是同时进行的。

Java 使用的线程调度是抢占式的。也就是说，JVM 本身不负责线程的调度，而是将线程的调度委托给操作系统。

### 单核CPU上运行多个线程效率一定会高吗?

对于单核 CPU 来说，如果任务是 CPU 密集型的，那么开很多线程会影响效率；如果任务是 IO 密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。

### 使用多线程会带来什么问题？

而且并发编程可能会遇到很多问题，比如：**内存泄漏、死锁、线程不安全等等**

要保证多线程的允许是安全，不要出现数据竞争造成的数据混乱的问题。
Java的线程安全在三个方面体现：

1. **原子性：**提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic和synchronized这两个关键字来确保原子性；
2. **可见性：**一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；
3. **有序性：**一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性

### 如何理解线程安全和不安全？

线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。

### 保证数据一致性有哪些方案？

1. **事务管理：**使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。
2. **锁机制：**使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 **synchronized 关键字、ReentrantLo**ck **或其他锁机制来控制并发访问**，从而避免并发操作导致数据不一致。
3. **版本控制：**通过**乐观锁的方式，在更新数据时记录数据的版本信息**，从而避免同时对同一数据进行修改，进而保证数据的一致性。

### 怎么保证多线程安全？

1. synchronized关键字:可以使用synchronized关键字来同步代码块或方法，确保同一时刻只有一个线程可以访问这些代码。对象锁是通过synchronized关键字锁定对象的监视器（monitor）来实现的。
2. Lock接口和ReentrantLock类:java.util.concurrent.locks.Lock接口提供了比synchronized更强大的锁定机制，ReentrantLock是一个实现该接口的例子，提供了更灵活的锁管理和更高的性能
3. volatile关键字:volatile关键字用于变量，确保所有线程看到的是该变量的最新值，而不是可能存储在本地寄存器中的副本。
4. 原子类：Java并发库（java.util.concurrent.atomic）提供了原子类，如AtomicInteger、AtomicLong等，这些类提供了原子操作，可以用于更新基本类型的变量而无需额外的同步
5. 线程局部变量:ThreadLocal类可以为每个线程提供独立的变量副本，这样每个线程都拥有自己的变量，消除了竞争条件。
6. 并发集合:使用java.util.concurrent包中的线程安全集合，如ConcurrentHashMap、ConcurrentLinkedQueue等，这些集合内部已经实现了线程安全的逻辑。
7. JUC工具类: 使用java.util.concurrent包中的一些工具类可以用于控制线程间的同步和协作。例如：Semaphore和CyclicBarrier等

### ---------死锁--------

### 如何检查死锁

- 使用jmap、jstack等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，jstack 的输出中通常会有 Found one Java-level deadlock:的字样，后面会跟着死锁相关的线程信息。
- 另外，实际项目中还可以搭配使用top、df、free等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。
- 采用 VisualVM、JConsole 等工具进行排查。

### 如何预防和避免线程死锁

如何预防死锁？ 破坏死锁的产生的必要条件即可：

- 破坏请求与保持条件：一次性申请所有的资源。
- 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

如何避免死锁？
避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

### -------JMM---------

### ----volatile关键字--

#### volatile关键字有什么作用？

volatite作用有 2 个：

- **保证变量对所有线程的可见性。**当一个变量被声明为volatile时**，它会保证对这个变量的写操作会立即刷新到主存中，而对这个变量的读操作会直接从主存中读取，从而确保了多线程环境下对该变量访问的可见性。**这意味着一个线程修改了volatile变量的值，其他线程能够立刻看到这个修改，不会受到各自线程工作内存的影响。
- **禁止指令重排序优化**。volatile关键字在Java中主要通过内存屏障来禁止特定类型的指令重排序。
  - 1）写-写（Write-Write）屏障：**在对volatile变量执行写操作之前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到volatile写操作之后。**
  - 2）读-写（Read-Write）屏障：**在对volatile变量执行读操作之后，会插入一个读屏障。它确保了对volatile变量的读操作之后的所有普通读操作都不会被提前到volatile读之前执行，保证了读取到的数据是最新的。**
  - 3）写-读（Write-Read）屏障：这**是最重要的一个屏障，它发生在volatile写之后和volatile读之前。这个屏障确保了volatile写操作之前的所有内存操作（包括写操作）都不会被重排序到volatile读之后，同时也确保了volatile读操作之后的所有内存操作（**包括读操作）都不会被重排序到volatile写之前。



#### 如何保证变量的可变性

- 在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。
- volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。



#### 指令重排序的原理是什么

在执行程序时，为了提高性能，处理器和编译器常常会对指令进行重排序，但是重排序要满足下面 2 个条件才能进行：

- **在单线程环境下不能改变程序运行的结果**
- **存在数据依赖关系的不允许重排序。**

所以重排序不会对单线程有影响，只会破坏多线程的执行语义。
，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面，如果C排到A和B的前面，那么程序的结果将会被改变。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序



#### 如何禁止指令重排序

- 在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。

- **“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”**

- 双重校验锁实现对象单例（线程安全）：

  ```java
  public class Singleton {
  
      private volatile static Singleton uniqueInstance;
  
      private Singleton() {
      }
  
      public  static Singleton getUniqueInstance() {
         //先判断对象是否已经实例过，没有实例化过才进入加锁代码
          if (uniqueInstance == null) {
              //类对象加锁
              synchronized (Singleton.class) {
                  if (uniqueInstance == null) {
                      uniqueInstance = new Singleton();
                  }
              }
          }
          return uniqueInstance;
      }
  }
  
  ```

  uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：

  1. 为 uniqueInstance 分配内存空间
  2. 初始化 uniqueInstance
  3. 将 uniqueInstance 指向分配的内存地址

  但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化
  
  

#### volatile可以保证原子性吗

volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。

#### volatile可以保证线程安全性嘛？

volatile关键字可以保证可见性，**但不能保证原子性，因此不能完全保证线程安全。**volatile关键字用于修饰变量，当一个线程修改了volatile修饰的变量的值，其他线程能够立即看到最新的值，从而避免了线程之间的数据不一致。
但是，volatile并不能解决多线程并发下的复合操作问题**，比如i++这种操作不是原子操作，如果多个线程同时对i进行自增操作，volatile不能保证线程安全。对于复合操作，需要使用synchronized关键字或者Lock来保证原子性和线程安全。**



### --乐观锁和悲观锁---

### 悲观锁和乐观锁

#### 悲观锁

认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以**每次在获取资源操作的时候都会上锁**，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。

像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现

- 高并发的场景下，激烈的锁竞争会造成线程阻塞，**大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。**
- 并且，悲观锁还可能会存在**死锁**问题，影响代码的正常运行

#### 乐观锁

乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，**只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了**（具体方法可以使用**版本号机制或 CAS 算法）。**

如果**冲突频繁发生（写占比非常多的情况），会频繁失败和重试**，这样同样会非常影响性能，导致 CPU 飙升。

### 如何实现乐观锁

乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。

#### 1. 版本号机制

一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功

#### 2. CAS**算法**

- CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是**用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。**
- CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。
  - CAS 涉及到三个操作数：
    V：要更新的变量值(Var)
    E：预期值(Expected)
    N：拟写入的新值(New)
  - 当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。
  - 线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6）
- sun.misc包下的Unsafe类提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作
- 由于 CAS 操作可能会因为并发冲突而失败，因此通常会与while循环搭配使用，在失败后不断重试，直到操作成功。这就是 自旋锁机制

#### 3. 时间戳

使用时间戳记录数据的更新时间，在更新数据时，在比较时间戳。如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败。

### Java中CAS是如何实现的？

在 Java 中，实现 CAS（Compare-And-Swap, 比较并交换）操作的一个关键类是Unsafe。Unsafe类位于sun.misc包下，是一个提供低级别、不安全操作的类。由于其强大的功能和潜在的危险性，它通常用于 JVM 内部或一些需要极高性能和底层访问的库中，而不推荐普通开发者在应用程序中使用。

Unsafe类中的 CAS 方法是native方法。native关键字表明这些方法是用本地代码（通常是 C 或 C++）实现的，而不是用 Java 实现的。这些方法直接调用底层的硬件指令来实现原子操作。也就是说，Java 语言并没有直接用 Java 实现 CAS，而是通过 C++ 内联汇编的形式实现的（通过 JNI 调用）。因此，CAS 的具体实现与操作系统以及 CPU 密切相关。

### CAS算法存在哪些问题?

#### 1. ABA问题

如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。

ABA 问题的解决思路是在变量前面追加上版本号或者时间戳。首先检查**当前引用是否等于预期引用，**并且**当前标志是否等于预期标志**，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

#### 2. 循环时间长开销大

CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。

如**果 JVM 能够支持处理器提供的pause指令，那么自旋操作的效率将有所提升**。pause指令有两个重要作用：

- 延迟流水线执行指令：**pause指令可以延迟指令的执行，从而减少 CPU 的资源消耗**。具体的延迟时间取决于处理器的实现版本，在某些处理器上，延迟时间可能为零。
- **避免内存顺序冲突**：在退出循环时，pause指令可以避免由于内存顺序冲突而导致的 CPU 流水线被清空，从而提高 CPU 的执行效率。

#### 3. 只能保证一个共享变量的原子操作

- CAS 操作仅能对单个共享变量有效。当**需要操作多个共享变量时，CAS 就显得无能为力。**
  - 从 JDK 1.5 开始，Java 提供了AtomicReference类，这使得我们能够保证引用对象之间的原子性。通过**将多个变量封装在一个对象中**，我们**可以使用AtomicReference来执行 CAS 操作。**
  - **除了 AtomicReference 这种方式之外，还可以利用加锁来保证**

#### 为什么不能所有的锁都用CAS？

CAS操作是基于循环重试的机制，如果CAS操作一直未能成功，线程会一直自旋重试，占用CPU资源。在高并发情况下，大量线程自旋会导致CPU资源浪费

### --------锁-----------

### Java中有那些锁？

1. **内置锁（synchronized）：**Java中的synchronized关键字是内置锁机制的基础，可以用于方法或代码块。当一个线程进入synchronized代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。如果其他线程尝试获取同一个对象的锁，它们将被阻塞，直到锁被释放。其中，syncronized加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁。

2. **ReentrantLock：**java.util.concurrent.locks.ReentrantLock是一个显式的锁类，提供了比synchronized更高级的功能，**如可中断的锁等待、定时锁等待、公平锁选项等**。ReentrantLock使用lock()和unlock()方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿。

3. **读写锁（ReadWriteLock）**：java.util.concurrent.locks.ReadWriteLock接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。

4. **乐观锁和悲观锁**：悲观锁（Pessimistic Locking）通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。synchronized和ReentrantLock都是悲观锁的例子。乐观锁（Optimistic Locking）通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。

5. **自旋锁**：自旋锁是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃CPU并阻塞。通常可以使用CAS来实现。这在锁等待时间很短的情况下可以提高性能，但过度自旋会浪费CPU资源。

   

### 公平锁和非公平锁有什么区别

- 公平锁 : 锁被释放之后，**先申请的线程先得到锁。性能较差一些，**因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
- 非公平锁：**锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的**。性能更好，但可能会导致某些线程永远无法获取到锁。



### 非公平锁吞吐量为什么比公平锁大？

- 公平锁执行流程：**获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，**锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，**再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。**
- 非公平锁执行流程：当线程获取锁时，**会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。**



### Synchronized是公平锁吗？

Synchronized不属于公平锁，ReentrantLock是公平锁。



### 怎么在实践中用锁的？

1. synchronized

   synchronized关键字可以用于方法或代码块，它是Java中最早的锁实现，使用起来非常简单。

   1. synchronized方法

      ```java
      public class Counter {
      private int count = 0;
      public synchronized void increment() {
      count++;
      }
      public synchronized int getCount() {
      return count;
      }
      }
      ```

   2. synchronized代码块

      ```java
      public class Counter {
      private Object lock = new Object();
      private int count = 0;
      public void increment() {
      synchronized (lock) {
      count++;
      }
      }
      }
      ```

2. Lock接口1-ReentrantLock

   Lock接口提供了比synchronized更灵活的锁操作，包括尝试锁、可中断锁、定时锁等。ReentrantLock是Lock接口的一个实现。

   ```java
   import java.util.concurrent.locks.Lock;
   import java.util.concurrent.locks.ReentrantLock;
   public class Counter {
   private Lock lock = new ReentrantLock();
   private int count = 0;
   public void increment() {
   lock.lock();
   try {
   count++;
   } finally {
   lock.unlock();
   }
   }
   }
   ```

3. Lock接口2-ReadWriteLock

   ```java
   import java.util.concurrent.locks.Lock;
   import java.util.concurrent.locks.ReadWriteLock;
   import java.util.concurrent.locks.ReentrantReadWriteLock;
   public class Cache {
   private ReadWriteLock lock = new ReentrantReadWriteLock();
   private Lock readLock = lock.readLock();
   private Lock writeLock = lock.writeLock();
   private Object data;
   public Object readData() {
   readLock.lock();
   try {
   return data;
   } finally {
   readLock.unlock();
   }
   }
   public void writeData(Object newData) {
   writeLock.lock();
   try {
   data = newData;
   } finally {
   writeLock.unlock();
   }
   }
   }
   ```

### ----synchronized---

### 什么是synchronized？有什么用

synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证**被它修饰的方法或者代码块在任意时刻只能有一个线程执行。**



### 如何使用synchronized

synchronized 关键字的使用方式主要有下面 3 种：

1. 修饰实例方法（锁当前对象实例）

   给当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁

   `synchronized void method() {`
       `//业务代码`
   `}`

2. 修饰静态方法（锁当前类）

   给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。静态成员不属于任何一个实例对象，**归整个类所有**，不依赖于类的特定实例，被类的所有实例共享。

   `synchronized static void method() {`
       `//业务代码`
   `}`

   **访问静态 synchronized 方法占用的锁是当前类的锁，**
   **而访问非静态 synchronized 方法占用的锁是当前实例对象锁，所以不互斥**

3. 修饰代码块（锁指定对象/类）

   对括号里指定的对象/类加锁：
   synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。
   synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁

总结：

1. synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁；
2. synchronized 关键字加到实例方法上是给对象实例上锁；
3. 尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能



### 构造方法可以用synchronized修饰吗

**构造方法不能使用 synchronized 关键字修饰。**不过，**可以在构造方法内部使用 synchronized 代码块。**

### synchronized底层原理了解吗

synchronized 关键字底层原理属于 JVM 层面的东西

#### 1. synchronized同步语句块的情况

synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。

#### 2. synchronized修饰方法的情况

synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，**取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。**

**不过两者的本质都是对对象监视器 monitor 的获取。**



### jdk1.6之后synchronized底层做了哪些优化？锁升级原理了解吗

在 Java 6 之后， synchronized 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多

锁主要存在四种状态，依次是**：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，**他们会随着竞争的激烈而逐渐升级。**注意锁可以升级不可降级，**这种策略是为了提高获得锁和释放锁的效率。

1. **无锁：这是没有开启偏向锁的时候的状态，**在JDK1.6之后偏向锁的默认开启的**，但是有一个偏向延迟，需要在JVM启动之后的多少秒之后才能开启，**这个可以通过JVM参数进行设置，同时是否开启偏向锁也可以通过JVM参数设置。
2. **偏向锁：这个是在偏向锁开启之后的锁的状态**，如果还**没有一个线程拿到这个锁的话，这个状态叫做匿名偏向**，当一**个线程拿到偏向锁的时候，下次想要竞争锁只需要拿线程ID跟MarkWord当中存储的线程ID进行比较，如果线程ID相同则直接获取锁（相当于锁偏向于这个线程）**，不需要进行CAS操作和将线程挂起的操作。
3. 轻量级锁**：在这个状态下线程主要是通过CAS操作实现的。将对象的MarkWord存储到线程的虚拟机栈上，然后通过CAS将对象的MarkWord的内容设置为指向Displaced Mark Word的指针，如果设置成功则获取锁。在线程出临界区的时候，也需要使用CAS，如果使用CAS替换成功则同步成功，如果失败表示有其他线程在获取锁，那么就需要在释放锁之后将被挂起的线程唤醒。**
4. 重量级锁：**当有两个以上的线程获取锁的时候轻量级锁就会升级为重量级锁，因为CAS如果没有成功的话始终都在自旋，进行while循环操作，这是非常消耗CPU的，但是在升级为重量级锁之后，线程会被操作系统调度然后挂起，这可以节约CPU资源**

<img src="D:\2024\Notes\Typora\八股\Java.assets\image-20241015122000249.png" alt="image-20241015122000249" style="zoom:50%;" />

> 线程A进入 synchronized 开始抢锁，JVM 会判断当前是否是偏向锁的状态，如果是就会根据 Mark Word 中存储的线程 ID 来判断，当前线程A是否就是持有偏向锁的线程。如果是，则忽略 check，线程A直接执行临界区内的代码。
> 但如果 Mark Word 里的线程不是线程 A，就会通过自旋尝试获取锁，如果获取到了，就将 Mark Word 中的线程 ID 改为自己的;**如果竞争失败，就会立马撤销偏向锁，膨胀为轻量级锁。**
> 后续的竞争线程都会通过自旋来尝试获取锁，如果自旋成功那么锁的状态仍然是轻量级锁。**然而如果竞争失败，锁会膨胀为重量级锁，后续等待的竞争的线程都会被阻塞。**



### JVM对synchronized的优化？

synchronized 核心优化方案主要包含以下 4 个：

1. **锁膨胀**：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。**JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，**而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，**这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了**，这样就大幅的提升了 synchronized 的性能。
2. **锁消除：**指的是在某些情况下，**JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，**从而到底提高程序性能的目的。
3. **锁粗化**：将多个连续的加锁、解锁操作连接在一起，**扩展成一个范围更大的锁。**
4. **自适应自旋锁：**指通过自身循环，尝试获取锁的一种方式，**优点在于它避免一些线程的挂起和恢复操作**，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。





### synchronized和volatile有什么区别

- Synchronized解决了多线程访问共享资源时可能出现的竞态条件和数据不一致的问题，保证了线程安全性。
- Volatile解决了变量在多线程环境下的可见性和有序性问题，确保了变量的修改对其他线程是可见的。

synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！

|                | volatile                                                     | synchronized                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------ |
| 性能           | `volatile` 关键字是线程同步的轻量级实现，<br />所以 `volatile`性能肯定比`synchronized`关键字要好 |                                      |
| 用途           | 只能用于变量                                                 | 可以修饰方法以及代码块               |
| 可见性和原子性 | 能保证数据的可见性，但不能保证数据的原子性                   | 保证可见性和原子性                   |
| 解决问题       | 用于解决变量在多个线程之间的可见性和禁止指令重排序           | 多个线程之间访问资源的同步性、互斥性 |

Synchronized: Synchronized是一种排他性的同步机制，保证了多个线程访问共享资源时的互斥性，即同一时刻只允许一个线程访问共享资源。通过对代码块或方法添加Synchronized关键字来实现同步。
Volatile: Volatile是一种轻量级的同步机制，用来保证变量的可见性和禁止指令重排序。当一个变量被声明为Volatile时，线程在读取该变量时会直接从内存中读取，而不会使用缓存，同时对该变量的写操作会立即刷回主内存，而不是缓存在本地内存中



### ---ReentrantLock--

### ReentrantLock是什么

ReentrantLock **实现了 Lock 接口**，是一个**可重入且独占式的锁**，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。

ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。

### ReentrantLock怎么实现公平锁的？

- 可以明显的看出公平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取锁时多了一个限制条件：hasQueuedPredecessors() 为 false，这个方法就是判断在等待队列中是否已经有线程在排队了。
- 这也就是公平锁和非公平锁的核心区别，如果是公平锁，那么一旦已经有线程在排队了，当前线程就不再尝试获取锁；对于非公平锁而言，无论是否已经有线程在排队，都会尝试获取一下锁，获取不到的话，再去排队。这里有一个特例需要我们注意，针对 tryLock() 方法，它不遵守设定的公平原则。



### synchronized和ReentrantLock及其应用场景

#### synchronized

- synchronized是Java提供的原子性内置锁，这种内置的并且使用者看不到的所也被称为监视器锁。

- 使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令

  - 执行monitorenter指令会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1
  - 此事件其他竞争锁的线程则会进入等待队列中。
  - 执行monitorexit指令则会把计数器-1，当计数器值为0时，锁释放，处于等待队列中的线程再继续竞争锁。

- synchronized是排他锁，当一个线程获得锁之后，其他线程必须等待该线程释放锁以后才能获得锁，
  由于java中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时会从用户态切换到内核态，这种转换非常消耗性能。

- 从内存语义来说，**加锁的过程会清除工作内存中的共享变量，再从主内存读取**，而释放锁的过程则是将工作内存中的共享变量写回主内存。

- 深入到源码来说，synchronized实际上有两个队列waitSet和entryList

  - 当多个线程进入同步代码块时，首先进入entryList
  - 有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1
  - 如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyall之后又会进入entryList竞争锁
  - 如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null、

  ![image-20241015104658642](D:\2024\Notes\Typora\八股\Java.assets\image-20241015104658642.png)

#### reentrantlock

- reentrantlock的底层实现主要依赖于AQS，AOS是一个提供了基本同步机制的框架，其中包含了队列、状态值等

- reentrantlock在aqs的基础上通过内部类sync来实现具体的锁操作。不同的sync子类实现了公平锁和非公平锁的不同逻辑

  - **可中断性**

    reentrantlock实现了可中断性，意味着在等待锁的过程中，可以被其他线程中断而提前结束等待。在底层，reentrantlock使用了与locksupport.park和locksupport.unpark相关的机制来实现可中断性

  - **设置超时时间**

    reentrantlock支持在尝试获取锁时设置超时时间，即等待一定时间以后如果还未获得锁，则放弃锁的获取。这是通过内部的tryAcquireNanos方法来实现的

  - **公平锁和非公平锁**

    直接创建reentrantlock对象时，默认情况下是非公平锁。公平锁是按照线程等待的顺序来获取锁，但是非公平锁则允许多个线程在同一时刻竞争锁，不考虑他们申请的顺序，公平锁可以通过在创建reentrantlock时传入true来设置

  - **多个条件变量**

    每个条件变量可以与同一个reentrantlock关联，这使得线程可以更灵活地进行等待和唤醒操作，而不仅仅是基于对象监视器的wait和notify。多个条件变量的实现依赖于condition接口

  - 可重入性

    reentrantlock支持可重入性，即同一个线程可以多次获得同一把锁，而不会造成死锁。这是通过内部的holdCount计数来实现的。当一个线程多次获取锁时，holdCount递增，释放锁的时候递减，只有当holdCount为0时，其他线程才有机会获取锁。

#### 应用场景的区别

- synchronized
  - **简单同步需求** synchronized使用简单，不需要额外的资源管理，锁在方法推出或者代码块执行完毕以后会自动释放
  - **代码块同步** 使用synchronized代码块，可以更精细的控制同步的范围，从而减少锁的持有时间，提高并发性能。
  - **内置锁的使用** synchronized关键字使用对象的内置锁（也被称为监视器锁），这在需要使用对象作为锁对象的情况下很有用，尤其是对象状态与锁保护的代码紧密相关时
- reentrantlock
  - 高级锁功能需求，reentrantlock提供了synchronized所不具备的高级功能，如**公平锁、响应中断、定时锁尝试、以及多个条件变量**
  - 性能优化，在高度竞争的环境中，renentrantlock可以提供更好的性能，因为**他提供了更细的锁粒度支持，如尝试锁定和定时锁定，可以减少更多线程阻塞的可能性，**
  - 复杂的同步结构 **需要多个条件变量来协调线程之间的通信时，reentrantlock及其配套的condition对象可以提供灵活的解决方案。**

synchronized适用于**简单同步需求和不需要额外锁功能的场**景，而ReentrantLock适用于**需要更高级锁功能、性能优化或复杂同步逻辑的**情况。选择哪种同步机制取决于具体的应用需求和性能考虑。

### synchronized和ReentrantLock

1. 两者都是可重入锁

   - 可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁

2. synchronized依赖于JVM而ReentrantLock依赖于API

   synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。

   1. synchronized 是依赖于 JVM 实现的
   2. ReentrantLock 是 JDK 层面实现的，也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成

3. ReentranLock比synchronized增加了一些高级功能

   1. 等待可中断

      ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断

   2. 可实现公平锁

      synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。

   3. 可实现选择性通知（锁可以绑定多个条件）:

      synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。
      ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。

4. 用法不同：synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。

5. 获取锁和释放锁方式不同：synchronized 会自动加锁和释放锁，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁。而 ReentrantLock 需要手动加锁和释放锁

   

### 怎么理解可重入锁

可重入锁是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。
ReentrantLock实现可重入锁的机制是基于线程持有锁的计数器。

- 当一个线程第一次获取锁时，计数器会加1，表示该线程持有了锁。在此之后，如果同一个线程再次获取锁，计数器会再次加1。每次线程成功获取锁时，都会将计数器加1。
- 当线程释放锁时，计数器会相应地减1。只有当计数器减到0时，锁才会完全释放，其他线程才有机会获取锁。
- 这种计数器的设计使得同一个线程可以多次获取同一个锁，而不会造成死锁或其他问题。每次获取锁时，计数器加1；每次释放锁时，计数器减1。只有当计数器减到0时，锁才会完全释放。

ReentrantLock通过这种计数器的方式，实现了可重入锁的机制。它允许同一个线程多次获取同一个锁，并且能够正确地处理锁的获取和释放，避免了死锁和其他并发问题。

### synchronized如何实现可重入的？

synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。

**synchronized底层是利用计算机系统mutex Lock实现的。每一个可重入锁都会关联一个线程ID和一个锁状态status。**

当一个线程请求方法时，会去检查锁状态。

1. 如果锁状态是0，代表该锁没有被占用，使用CAS操作获取锁，将线程ID替换成自己的线程ID。
2. 如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法；如果是非重入锁，就会进入阻塞队列等待。

在释放锁时，

1. 如果是可重入锁的，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。
2. 如果非可重入锁的，线程退出方法，直接就会释放该锁



### 可中断锁和非可中断锁有什么区别

- 可中断锁：**获取锁的过程中可以被中断，**不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。
- 不可中断锁：**一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁**



### ------读写锁-------

#### -ReentrantReadQriteLock-

ReentrantReadWriteLock 实现了 ReadWriteLock ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。

#### --StampedLock--

StampedLock 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 Condition。

### --Atomic原子类---

原子类简单来说就是具有原子性操作特征的类。**Atomic 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 synchronized 块或 ReentrantLock）。**

将JUC包中的原子类分为4类

1. 基本类型
2. 数组类型
3. 引用类型
4. 对象的属性修改类型

### ---ThreadLocal----

### ThreadLocal有什么用

1. **线程隔离：ThreadLocal为每个线程提供了独立的变量副本，这意味着线程之间不会相互影响，**可以安全地在多线程环境中使用这些变量而不必担心数据竞争或同步问题。

   如**果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本**，这也是ThreadLocal变量名的由来。他们**可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。**

2. 降低耦合度：在同一个线程内的多个函数或组件之间，**使用ThreadLocal可以减少参数的传递，降低代码之间的耦合度，**使代码更加清晰和模块化。

3. 性能优势：由于ThreadLocal避免了线程间的同步开销，所以在大量线程并发执行时，相比传统的锁机制，它可以提供更好的性能

### ThreadLocal原理了解吗

Thread类源码

```java
public class Thread implements Runnable {
    //......
    //与此线程有关的ThreadLocal值。由ThreadLocal类维护
    ThreadLocal.ThreadLocalMap threadLocals = null;

    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    //......
}
```

​	从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。

ThreadLocal类的set方法

```java
public void set(T value) {
    //获取当前请求的线程
    Thread t = Thread.currentThread();
    //取出 Thread 类内部的 threadLocals 变量(哈希表结构)
    ThreadLocalMap map = getMap(t);
    if (map != null)
        // 将需要存储的值放入到这个哈希表中
        map.set(this, value);
    else
        createMap(t, value);
}
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

​	最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。

​	**每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。**

```java
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
    //......
}
```

​	我们在同一个线程中声明了两个 ThreadLocal 对象的话， Thread内部都是使用仅有的那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。

​	ThreadLocalMap是ThreadLocal的静态内部类。

> 简单原理：
>
> ThreadLocal的实现依赖于Thread类中的一个ThreadLocalMap字段，这是一个存储ThreadLocal变量本身和对应值的映射。**每个线程都有自己的ThreadLocalMap实例，用于存储该线程所持有的所有ThreadLocal变量的值。**
>
> 当你创建一个ThreadLocal变量时，它实际上就是一个ThreadLocal对象的实例。每个ThreadLocal对象都可以存储任意类型的值，这个值对每个线程来说是独立的。
>
> - 当调用ThreadLocal的get()方法时，ThreadLocal会检查当前线程的ThreadLocalMap中是否有与之关联的值。
>   - 如果有，返回该值；
>   - 如果没有，会调用initialValue()方法（如果重写了的话）来初始化该值，然后将其放入ThreadLocalMap中并返回。
> - 当调用set()方法时，ThreadLocal会将给定的值与当前线程关联起来，即在当前线程的ThreadLocalMap中存储一个键值对，键是ThreadLocal对象自身，值是传入的值。
> - 当调用remove()方法时，会从当前线程的ThreadLocalMap中移除与该ThreadLocal对象关联的条目。

### ThreadLocal内存泄露问题是怎么导致的

当一个线程结束时，其ThreadLocalMap也会随之销毁，**但是ThreadLocal对象本身不会立即被垃圾回收，直到没有其他引用指向它为止。**
因此，在使用ThreadLocal时需要注意，**如果不显式调用remove()方法，或者线程结束时未正确清理ThreadLocal变量，可能会导致内存泄漏，因为ThreadLocalMap会持续持有ThreadLocal变量的引用，即使这些变量不再被其他地方引用。**
因此，实际应用中需要在使用完ThreadLocal变量后**调用remove()方法释放资源**

​	ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。
​	这样一来**，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。**ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后最好手动调用remove()方法

### -------线程池-------

### 什么是线程池

线程池就是管理一系列线程的资源池**。当有任务要处理时，直接从线程池中获取线程来处理，**处理完之后线程并**不会立即被销毁，而是等待下一个任务**

### 为什么要用线程池

- 池化主要是为了**减少每次获取资源的消耗，提高对资源的利用率**。线程池、数据库连接池、HTTP连接池都是对这个的应用。

- **线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。**

- 使用线程池的好处

  - 降低资源消耗

    通过重复利用已创建的线程降低线程创建和销毁造成的消耗

  - 提高响应速度

    当任务到达时，任务可以不需要等到线程创建就能立即执行。

  - 提高线程的可管理性
    线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控

### 如何创建线程池

- 通过**ThreadPoolExecutor构造函数**来创建（推荐）
- 通过**Executor框架的工具类**Executors来创建，可以创建多种类型的线程池
  - FixedThreadPool：**固定线程数量的线程池**。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
  - SingleThreadExecutor： **只有一个线程的线程池。**若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
  - CachedThreadPool： **可根据实际情况调整线程数量的线程池**。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。
  - ScheduledThreadPool：**给定的延迟后运行任务或者定期执行任务的线程池**

### Executor框架介绍

在 Java 5 之后，**通过 Executor 来启动线程比使用 Thread 的 start 方法更好，**除了更**易管理，效率更好**（用线程池实现，节约开销）外，还有关键的一点：**有助于避免 this 逃逸问题。**this 逃逸是**指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法**可能引发令人疑惑的错误。

Executor 框架结构主要由三大部分组成：

1. 任务(Runnable /Callable)
   执行任务需要实现的 Runnable 接口 或 Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。

2. 任务的执行(Executor)

3. **异步计算的结果(`Future`)**

   **`Future`** 接口以及 `Future` 接口的实现类 **`FutureTask`** 类都可以代表异步计算的结果。

   当我们把 **`Runnable`接口** 或 **`Callable` 接口** 的实现类提交给 **`ThreadPoolExecutor`** 或 **`ScheduledThreadPoolExecutor`** 执行。（调用 `submit()` 方法时会返回一个 **`FutureTask`** 对象）

Executor框架的使用示意图：

1. 主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。
2. 把创建完成的实现 Runnable/Callable接口的 对象直接交给 ExecutorService 执行: ExecutorService.execute（Runnable command））或者也可以把 Runnable 对象或Callable 对象提交给 ExecutorService 执行（ExecutorService.submit（Runnable task）或 ExecutorService.submit（Callable <T> task））。
3. 如果执行 ExecutorService.submit（…），ExecutorService 将返回一个实现Future接口的对象（我们刚刚也提到过了执行 execute()方法和 submit()方法的区别，submit()会返回一个 FutureTask 对象）。由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。
4. 最后，主线程可以执行 FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行

### 为什么不推荐使用内置线程池

《阿里巴巴 Java 开发手册》明确指出**线程资源必须通过线程池提供，不允许在应用中自行显式创建线程**

《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险

Executors返回线程池对象弊端如下：

- FixedThreadPool 和 SingleThreadExecutor:**使用的是有界阻塞队列是 LinkedBlockingQueue ，其任务队列的最大长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。**
- CachedThreadPool:**使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程**，从而导致 OOM。
- ScheduledThreadPool 和 SingleThreadScheduledExecutor :**使用的无界的延迟阻塞队列 DelayedWorkQueue ，任务队列最大长度为 Integer.MAX_VALUE ，可能堆积大量的请求，**从而导致 OOM。

**即使用有界队列，控制线程创建数量**

### 线程池常见参数有哪些？如何解释？

```java
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

ThreadPoolExecutor 3 个最重要的参数：

1. corePoolSize : 任务队列未达到队列容量时，**最大可以同时运行的线程数量。**
2. maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，**当前可以同时运行的线程数量变为最大线程数。**
3. workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

ThreadPoolExecutor其他常见参数 :

1. keepAliveTime:**当线程池中的线程数量大于 corePoolSize ，即有非核心线程（线程池中核心线程以外的线程）时，这些非核心线程空闲后不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁。**
2. unit : **keepAliveTime 参数的时间单位。**
3. threadFactory :**executor 创建新线程的时候会用到。**
4. handler :**拒绝策略（**后面会单独详细介绍一下）。

### 核心线程数可以设置为0吗？

可以，当**核心线程数为0的时候，会创建一个非核心线程进行执行。**
当核心线程数为 0 时，来了一个任务之后，会先将任务添加到任务队列，同时也会判断当前工作的线程数是否为 0，如果为 0，则会创建线程来执行线程池的任务

### 线程池的核心线程会被回收吗

- ThreadPoolExecutor **默认不会回收核心线程**，即使它们已经空闲了。这是**为了减少创建线程的开销，因为核心线程通常是要长期保持活跃的**
- 如果线程池**是被用于周期性使用的场景，且频率不高**（周期之间有明显的空闲时间），可以考虑将 allowCoreThreadTimeOut(boolean value) 方法的参数设置为 true，这样就会回收空闲（时间间隔由 keepAliveTime 指定）的核心线程了

### 线程池的拒绝策略有哪些？

如果**当前同时运行的线程数量达到最大线程数量**并且**队列也已经被放满了任务**时，ThreadPoolExecutor 定义一些策略:

- ThreadPoolExecutor.**AbortPolicy**：抛出 RejectedExecutionException来**拒绝新任务的处理。**
- ThreadPoolExecutor**.CallerRunsPolicy**：**调用执行自己的线程运行任务**，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，**如果执行程序已关闭，则会丢弃该任务。**因此这种策略会降低对于新任务提交速度，影响程序的整体性能。**如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，**你可以选择这个策略。
- ThreadPoolExecutor**.DiscardPolicy**：**不处理新任务，直接丢弃掉。**
- ThreadPoolExecutor**.DiscardOldestPolicy**：**此策略将丢弃最早的未处理的任务请求。**
- 自定义拒绝策略

### CallerRunsPolicy拒绝策略有什么风险？如何解决？

- 因为CallerRunsPolicy这个拒绝策略，导致**耗时的任务用了主线程执行**，导致**线程池阻塞**，进而导致**后续任务无法及时执行**，严重的情况下很可能**导致 OOM。**
  1. 调用者采用CallerRunsPolicy是**希望所有的任务都能够被执行，暂时无法处理的任务又被保存在阻塞队列BlockingQueue中**。这样的话，在内存允许的情况下，我们可以**增加阻塞队列BlockingQueue的**大小并调整堆内存以容纳更多的任务，确保任务能够被准确执行。
  2. 为了充分利用 CPU，我们还可以**调整线程池的maximumPoolSize （最大线程数）参数**，这样可以提高任务处理速度，避免累计在 BlockingQueue的任务过多导致内存用完。
  3. 导致主线程卡死的本质就是因为我们不希望任何一个任务被丢弃。提供的一种**任务持久化**的思路
     1. 设计一张任务表将任务存储到 MySQL 数据库中。
        - 实现RejectedExecutionHandler接口自定义拒绝策略，自定义拒绝策略负责将线程池暂时无法处理（此时阻塞队列已满）的任务入库（保存到 MySQL 中）。注意：**线程池暂时无法处理的任务会先被放在阻塞队列中，阻塞队列满了才会触发拒绝策略。**
        - 继承BlockingQueue实现一个混合式阻塞队列，该队列包含 JDK 自带的ArrayBlockingQueue。另外，该混合式阻塞队列需要修改取任务处理的逻辑，也就是重写take()方法，**取任务时优先从数据库中读取最早的任务，数据库中无任务时再从 ArrayBlockingQueue中去取任务。**
     2. Redis 缓存任务。
     3. 将任务提交到消息队列中。
  4. 以 Netty 为例，它的拒绝策略则是**直接创建一个线程池以外的线程处理这些任务，**为了保证任务的实时处理，这种做法可能需要良好的硬件设备且临时创建的线程无法做到准确的监控：
  5. ActiveMQ 则是**尝试在指定的时效内尽可能的争取将任务入队**，以保证最大交付：

### 线程池常用的阻塞队列有哪些

1. 容量为 Integer.MAX_VALUE 的 **LinkedBlockingQueue（有界阻塞队列）**：
   1. FixedThreadPool 和 SingleThreadExecutor 。
      1. FixedThreadPool最多只能创建核心线程数的线程（核心线程数和最大线程数相等），
      2. SingleThreadExecutor只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。
2. **SynchronousQueue（同步队列）**：
   1. CachedThreadPool 。SynchronousQueue 没有容量，不存储元素，**目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。**也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。
3. **DelayedWorkQueue（延迟队列）**：
   1. ScheduledThreadPool 和 SingleThreadScheduledExecutor 。DelayedWorkQueue 的内部元素并不是按**照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，**内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容，增加原来容量的 50%，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。
4. **ArrayBlockingQueue（有界阻塞队列）**：
   1. **底层由数组实现，容量一旦创建，就不能修改。**

### 线程池处理任务的流程？

1. 如果当前运行的线程数小于**核心线程数**，那么就会**新建一个线程**来执行任务。
2. 如果当前运行的线程数**等于或大于核心线程数，**但是**小于最大线程数**，那么就把该任务**放入到任务队列**里等待执行。
3. 如果向任务队列投放任务失败（**任务队列已经满了**），但是当前运行的线程数是小于最大线程数的，**就新建一个线程来执行任务**。
4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，**拒绝策略**会调用RejectedExecutionHandler.rejectedExecution()方法。

线程池在提交任务前，可以提前创建线程吗？

- ThreadPoolExecutor 提供了两个方法帮助我们在提交任务之前，完成核心线程的创建，从而实现线程池预热的效果：
  - prestartCoreThread():启动一个线程，等待任务，如果已达到核心线程数，这个方法返回 false，否则返回 true；
  - prestartAllCoreThreads():启动所有的核心线程，并返回启动成功的核心线程数

### 线程池中线程异常后，销毁还是复用

1. 使用execute()提交任务：**当任务通过execute()提交到线程池并在执行过程中抛出异常时**，如果这个异常**没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印**到控制台或日志文件中。线程池会**检测到这种线程终止，并创建一个新线程来替换它**，从而保持配置的线程数不变。
2. 使用submit()提交任务：对于通过submit()提交的任务，**如果在任务执行中发生异常，这个异常不会直接打印出来。**相反，**异常会被封装在由submit()返回的Future对象中。当调用Future.get()方法时，可以捕获到一个ExecutionException。**在这种情况下，**线程不会因为异常而终止，它会继续存在于线程池中**，准备执行后续的任务。

**使用execute()时，未捕获异常导致线程终止，线程池创建新线程替代；**

**使用submit()时，异常被封装在Future中，线程继续复用。**

### 如何给线程池命名

初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。

1. 利用guava的ThreadFactoryBuilder

   ```java
   ThreadFactory threadFactory = new ThreadFactoryBuilder()
                           .setNameFormat(threadNamePrefix + "-%d")
                           .setDaemon(true).build();
   ExecutorService threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);
   ```

2. 自己实现ThreadFactory

   ```java
   import java.util.concurrent.ThreadFactory;
   import java.util.concurrent.atomic.AtomicInteger;
   
   /**
    * 线程工厂，它设置线程名称，有利于我们定位问题。
    */
   public final class NamingThreadFactory implements ThreadFactory {
   
       private final AtomicInteger threadNum = new AtomicInteger();
       private final String name;
   
       /**
        * 创建一个带名字的线程池生产工厂
        */
       public NamingThreadFactory(String name) {
           this.name = name;
       }
   
       @Override
       public Thread newThread(Runnable r) {
           Thread t = new Thread(r);
           t.setName(name + " [#" + threadNum.incrementAndGet() + "]");
           return t;
       }
   }
   ```

### 如何设定线程池的大小

- 如果我们设置的线程池数量太小的话，如果**同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行**，**甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。**这样很明显是有问题的，CPU 根本没有得到充分利用。
- 如果我们设置线程数量太大，**大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换**，从而增加线程的执行时间，影响了整体执行效率。

- **CPU 密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数**多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一**旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N

#### 如何判断是CPU密集型任务还是IO密集型任务

CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型

### 如何动态修改线程池的参数

[Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)

美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。

### 如何设计一个能够根据任务的优先级来执行的线程？

- 假如我们需要实现一个优先级任务线程池的话，那**可以考虑使用 PriorityBlockingQueue （优先级阻塞队列）作为任务队列（ThreadPoolExecutor 的构造函数有一个 workQueue 参数可以传入任务队列）**
  - PriorityBlockingQueue 是一个支持优先级的无界阻塞队列，可以看作是线程安全的 PriorityQueue，两者底层都是使用小顶堆形式的二叉堆，即值最小的元素优先出队。不过，PriorityQueue 不支持阻塞操作。
  - 实现排序
    - 提交到线程池的任务实现 Comparable 接口，并重写 compareTo 方法来指定任务之间的优先级比较规则。
    - 创建 PriorityBlockingQueue 时传入一个 Comparator 对象来指定任务之间的排序规则(推荐)。
  - 可能存在的问题
    - PriorityBlockingQueue 是无界的，可能堆积大量的请求，从而导致 OOM。
      - 对于 OOM 这个问题的解决比较简单粗暴，就是继承PriorityBlockingQueue 并重写一下 offer 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 false 。
    - 可能会导致饥饿问题，即低优先级的任务长时间得不到执行。
      - 饥饿问题这个可以通过优化设计来解决（比较麻烦），比如等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。
    - 由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 ReentrantLock），因此会降低性能。

### Java线程池最佳实践

1. 正确声明线程池

   1. 线程池必须手动通过 ThreadPoolExecutor 的构造函数来声明，避免使用Executors 类创建线程池，**会有 OOM 风险。**
   2. 实际使用中需要根据自己机器的性能、业务场景来**手动配置线程池的参数比**如核心线程数、使用的任务队列、饱和策略等等。
   3. 我们应该**显示地给我们的线程池命名**，这样有助于我们定位问题。

2. 监测线程池运行状态

   1. 利用 ThreadPoolExecutor 的相关 API 做一个简陋的监控

3. 建议不同类别的业务用不同的线程池

4. 别忘记给线程池命名

5. 正确配置线程池参数

6. 别忘记关闭线程池

   当线程池不再需要使用时，应该显式地关闭线程池，释放线程资源。

   1. shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN**。线程池不再接受新任务了，**但是队列里的任务得执行完毕。

   2. shutdownNow（） :关闭线程池，线程池的状态变为 STOP。**线程池会终止当前正在运行的任务，**停止处理排队的任务并返回正在等待执行的 List。

      调用完 shutdownNow 和 shuwdown 方法后，**并不代表线程池已经完成关闭操作，它只是异步的通知线程池进行关闭处理**。如**果要同步等待线程池彻底关闭后才继续往下执行，需要调用awaitTermination方法进行同步等待。**

      在调用 awaitTermination() 方法时，**应该设置合理的超时时间，以避免程序长时间阻塞而导致性能问题**。另外。由于线程池中的任务可能会被取消或抛出异常，因此在使用 awaitTermination() 方法时还需**要进行异常处理**。awaitTermination() 方法会抛出 InterruptedException 异常，需要捕获并处理该异常，以避免程序崩溃或者无法正常退出

      

7. 线程池尽量不要放耗时的任务

   线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。
   因此，**在使用线程池时，我们应该尽量避免将耗时任务提交到线程池中执行。对于一些比较耗时的操作，如网络请求、文件读写等，可以采用 CompletableFuture 等其他异步操作的方式来处理**，以避免阻塞线程池中的线程

8. 线程池使用的一些小坑

   1. 重复创建线程池的坑

   2. Spring内部线程池的坑

   3. 线程池和ThreadLocal共用的坑

      线程池和 ThreadLocal共用，可能会导致线程从ThreadLocal获取到的是旧值/脏数据。**这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 ThreadLocal 变量也会被重用，这就导致一个线程可能获取到其他线程的ThreadLocal 值。**

      解决上述问题比较建议的办法是使用阿里巴巴开源的 TransmittableThreadLocal(TTL)。TransmittableThreadLocal类继承并加强了 JDK 内置的InheritableThreadLocal类，在使用线程池等会池化复用线程的执行组件情况下，提供ThreadLocal值的传递功能，解决异步执行时上下文传递的问题。

### Runnable和Callable

Runnable 接口不会返回结果或抛出检查异常，但是 Callable 接口可以

### Execute和Submit

1. 返回值

   1. execute() 方法用于提交不需要返回值的任务。通常用于执行 Runnable 任务，无法判断任务是否被线程池成功执行

   2. submit() 方法用于**提交需要返回值**的任务。可以提交 Runnable 或 Callable 任务。

      1. submit() **方法返回一个 Future 对象，通过这个 Future 对象可以判断任务是否执行成功，并获取任务的返回值**

         （get()方法会阻塞当前线程直到任务完成， get（long timeout，TimeUnit unit）多了一个超时时间，如果在 timeout 时间内任务还没有执行完，就会抛出 java.util.concurrent.TimeoutException）。

2. 异常处理

   1. **在使用 submit() 方法时，可以通过 Future 对象处理任务执行过程中抛出的异常**；
   2. **而在使用 execute() 方法时，异常处理需要通过自定义的** ThreadFactory （在线程工厂创建线程的时候设置UncaughtExceptionHandler对象来 处理异常）或 ThreadPoolExecutor 的 afterExecute() 方法来处理

### shutdown和shutdownNow

- shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。**线程池不再接受新任务了，但是队列里的任务得执行完毕。**
- shutdownNow（） :关闭线程池，线程池的状态变为 STOP。**线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List**

详细来说：

- shutdown使用了以后会置状态为SHUTDOWN，正在执行的任务会继续执行下去，没有被执行的则中断。此时，则不能再往线程池中添加任何任务，否则将会抛出 RejectedExecutionException 异常
- 而 shutdownNow 为STOP，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。 它试图终止线程的方法是通过调用 Thread.interrupt() 方法来实现的，但是这种方法的作用有限，**如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的**。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。

### isTerminated和isShutdown

- isShutDown 当调用 shutdown() 方法后返回为 true。
- isTerminated 当调用 shutdown() 方法后，**并且所有提交的任务完成后**返回为 true

### 提交给线程池中的任务可以被撤回吗？

可以，当向线程池提交任务时，会得到一个Future对象。这个Future对象提供了几种方法来管理任务的执行，包括取消任务。

取消任务的主要方法是Future接口中的cancel(boolean mayInterruptIfRunning)方法。这个方法尝试取消执行的任务。参数mayInterruptIfRunning指示是否允许中断正在执行的任务。如果设置为true，则表示如果任务已经开始执行，那么允许中断任务；如果设置为false，任务已经开始执行则不会被中断。

```java
public interface Future<V> {
// 是否取消线程的执行
boolean cancel(boolean mayInterruptIfRunning);
// 线程是否被取消
boolean isCancelled();
//线程是否执行完毕
boolean isDone();
// 立即获得线程返回的结果
V get() throws InterruptedException, ExecutionException;
// 延时时间后再获得线程返回的结果
V get(long timeout, TimeUnit unit)
throws InterruptedException, ExecutionException, TimeoutException;
}
```

取消线程池中任务的方式，代码如下，通过 future 对象的 cancel(boolean) 函数来定向取消特定的任务。

```java
public static void main(String[] args) {
ExecutorService service = Executors.newSingleThreadExecutor();
Future future = service.submit(new TheradDemo());
try {
// 可能抛出异常
future.get();
} catch (InterruptedException e) {
e.printStackTrace();
} catch (ExecutionException e) {
e.printStackTrace();
}finally {
//终止任务的执行
future.cancel(true);
}
```

### 几个常见的内置线程池？线程池的种类有哪些？

1. **FixedThreadPool**
   1. **固定大小的线程池，**线程数量由用户定义。
   2. 当线程数达到 corePoolSize 时，新任务会被放入无界队列 LinkedBlockingQueue 中等待执行。
   3. 使用无界队列可能导致内存溢出（OOM）问题。
   4. 不建议在无法预估任务量的情况下使用。
2. **SingleThreadExecutor**
   1. **单一线程的线程池**，适合顺序执行任务。
   2. 与 FixedThreadPool 类似，使用无界队列 LinkedBlockingQueue，同样可能引发内存溢出问题。
   3. 不建议在任务量不可控的情况下使用。
3. **CachedThreadPool**
   1. 根据需要创建新线程，使用 SynchronousQueue 作为工作队列。
   2. 无界线程池，可能导致大量线程创建，进而消耗过多系统资源，导致OOM
   3. 在任务量不稳定且难以预测的情况下，需谨慎使用。
4. **ScheduledThreadPool**
   1. **用于延时或周期性执行任务，使用 DelayedWorkQueue 作为任务队列。**
   2. 基于 ThreadPoolExecutor 实现，但具有调度功能。
   3. 与 Timer 相比
      1. Timer 对系统时钟变化敏感，而 ScheduledThreadPoolExecutor 则不是。
      2. Timer 内部只有一个执行线程，这意味着如果有任务运行时间过长，那么其他待执行的任务将会被延迟。ScheduledThreadPoolExecutor 允许配置多个线程，并且可以通过 ThreadFactory 来控制线程的创建
      3. Timer 在 TimerTask 抛出运行时异常时，可能会导致执行线程终止，从而使定时器失效，不再执行后续任务。ScheduledThreadPoolExecutor 能够捕获运行时异常，并允许通过重写 afterExecute 方法来自定义异常处理逻辑，即使某个任务因异常被取消，也不会影响其他任务的执行。
   4. 在设计定时任务时考虑使用，但在资源有限的环境中需注意其潜在的风险。

### 多线程打印奇偶数，怎么控制打印顺序

```java
public class PrintOddEven {
private static final Object lock = new Object();
private static int count = 1;
private static final int MAX_COUNT = 10;
public static void main(String[] args) {
Runnable printOdd = () -> {
synchronized (lock) {
while (count <= MAX_COUNT) {
if (count % 2 != 0) {
System.out.println(Thread.currentThread().getName() + ": " + count++);
lock.notify();
} else {
try {
lock.wait();
} catch (InterruptedException e) {
e.printStackTrace();
}
}
}
}
};
Runnable printEven = () -> {
synchronized (lock) {
while (count <= MAX_COUNT) {
if (count % 2 == 0) {
System.out.println(Thread.currentThread().getName() + ": " + count++);
lock.notify();
} else {
try {
lock.wait();
} catch (InterruptedException e) {
e.printStackTrace();
}
}
}
}
};
Thread oddThread = new Thread(printOdd, "OddThread");
Thread evenThread = new Thread(printEven, "EvenThread");
oddThread.start();
evenThread.start();
}
}
```

在上面的示例中，通过一个共享的锁对象lock来控制两个线程的交替执行。一个线程负责打印奇数，另一个线程负责打印偶数，通过wait()和notify()方法来在两个线程之间实现顺序控制。当当前应该打印奇数时，偶数线程会进入等待状态，反之亦然

### -------Future-------

### Future类有什么用？

Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，

当我们执行某一耗时的任务时，**可以将这个耗时任务交给一个子线程去异步执行，**同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，**我们再通过 Future 类获取到耗时任务的执行结果**

在 Java 中，Future 类只是一个泛型接口，位于 java.util.concurrent 包下，定义了 5 个方法，主要包括下面这 4 个功能：

1. **取消任务；**
2. **判断**任务**是否被取消**;
3. **判断**任务**是否已经执行完成;**
4. **获取任务执行结果。**

Future接口有5个方法

1. boolean cancel(boolean mayInterruptIfRunning)：尝试取消执行任务。
2. boolean isCancelled()：判断任务是否被取消。
3. boolean isDone()：判断任务是否已经被执行完成。
4. get()：等待任务执行完成并获取运算结果。
5. get(long timeout, TimeUnit unit)：多了一个超时时间。

### Callable和Future有什么关系?

- FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask 。
  - **FutureTask 不光实现了 Future接口，还实现了Runnable 接口，可以作为任务直接被线程执行。**
  - FutureTask **有两个构造函数，可传入 Callable 或者 Runnable 对象。**实际上，传入 Runnable 对象也会在方法内部转换为Callable 对象。**FutureTask相当于对Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。**

### CompletableFuture类有什么用？

- Future 在实际使用过程中存在一些局限性比如**不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。**

- Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了**函数式编程、异步任务编排组合（**可以**将多个异步任务串联起来，组成一个完整的链式调用**）等能力。
  - CompletableFuture 同时**实现了 Future 和 CompletionStage 接口。**
  - **CompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。**
  - CompletionStage 接口中的方法比较多，CompletableFuture 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。
  
- Future(ListenableFuture)的实现（回调地狱）如下：

  ```java
  ExecutorService executor = Executors.newFixedThreadPool(5);
  ListeningExecutorService guavaExecutor = MoreExecutors.listeningDecorator(executor);
  ListenableFuture<String> future1 = guavaExecutor.submit(() -> {
  //step 1
  System.out.println("执行step 1");
  return "step1 result";
  });
  ListenableFuture<String> future2 = guavaExecutor.submit(() -> {
  //step 2
  System.out.println("执行step 2");
  return "step2 result";
  });
  ListenableFuture<List<String>> future1And2 = Futures.allAsList(future1, future2);
  Futures.addCallback(future1And2, new FutureCallback<List<String>>() {
  @Override
  public void onSuccess(List<String> result) {
  System.out.println(result);
  ListenableFuture<String> future3 = guavaExecutor.submit(() -> {
  System.out.println("执行step 3");
  return "step3 result";
  });
  Futures.addCallback(future3, new FutureCallback<String>() {
  @Override
  public void onSuccess(String result) {
  System.out.println(result);
  }
  @Override
  public void onFailure(Throwable t) {
  }
  }, guavaExecutor);
  }
  @Override
  public void onFailure(Throwable t) {
  }}, guavaExecutor);
  ```

- CompletableFuture

  ```java
  ExecutorService executor = Executors.newFixedThreadPool(5);
  CompletableFuture<String> cf1 = CompletableFuture.supplyAsync(() -> {
  System.out.println("执行step 1");
  return "step1 result";
  }, executor);
  CompletableFuture<String> cf2 = CompletableFuture.supplyAsync(() -> {
  System.out.println("执行step 2");
  return "step2 result";
  });
  cf1.thenCombine(cf2, (result1, result2) -> {
  System.out.println(result1 + " , " + result2);
  System.out.println("执行step 3");
  return "step3 result";
  }).thenAccept(result3 -> System.out.println(result3));
  ```

### CompletableFuture常见操作

#### 1. 创建CompletableFuture

- 通过 new 关键字。
- 基于 CompletableFuture 自带的静态工厂方法：runAsync()、supplyAsync() 。
  - runAsync() 方法接受的参数是 Runnable ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 runAsync() 方法。
  - supplyAsync() 方法接受的参数是 Supplier<U> ，这也是一个函数式接口，U 是返回结果值的类型。

#### 2. 处理异步计算的结果

- thenApply() 方法接受一个 Function 实例，用它来处理结果。
- 如果你不需要从回调函数中获取返回结果，可以使用 thenAccept() 或者 thenRun()。这两个方法的区别在于 thenRun() 不能访问异步计算的结果。
- whenComplete() 的方法的参数是 BiConsumer<? super T, ? super Throwable> 。相对于 Consumer ， BiConsumer 可以接收 2 个输入对象然后进行“消费”。

#### 3. 异常处理

- 可以通过 handle() 方法来处理任务执行过程中可能出现的抛出异常的情况。
- 可以通过 exceptionally() 方法来处理异常情况。
- 如果想让 CompletableFuture 的结果就是异常的话，可以使用 completeExceptionally() 方法为其赋值。

#### 4. 组合CompletableFuture

- thenCompose() 可以链接两个 CompletableFuture 对象，并将前一个任务的返回结果作为下一个任务的参数，它们**之间存在着先后顺序。**
- thenCombine() 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是**并行执行的，它们之间并没有先后依赖顺序。**

#### 5. 并行运行多个CompletableFuture

- allOf() 方法会等到所有的 CompletableFuture 都运行完成之后再返回
- anyOf() 方法不会等待所有的 CompletableFuture 都运行完成之后再返回，只要有一个执行完成即可！

### CompletableFuture使用建议

1. 使用自定义线程池

   1. 默认是ForkJoinPool，虽然效率很高，但当同时提交大量任务时，可能会导致资源竞争和线程饥饿，进而影响系统性能。
   2. 自定义优点
      1. **隔离性**：为不同任务分配独立的线程池，避免全局线程池资源争夺。
      2. 资源控制：**根据任务特性调整线程池大小和队列类型，**优化性能表现。
      3. **异常处理：**通过自定义 ThreadFactory 更好地处理线程中的异常情况。

2. 尽量避免使用get()

   CompletableFuture的get()方**法是阻塞的**，尽量避免使用。**如果必须要使用的话，需要添加超时时间**，否则可能会导致主线程一直等待，无法执行其他任务。

3. 正确进行异常处理

4. 合理组合多个异步任务



[CompletableFuture原理与实践-外卖商家端API的异步化 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html)：这篇文章详细介绍了 CompletableFuture 在实际项目中的运用。参考这篇文章，可以对项目中类似的场景进行优化，也算是一个小亮点了。这种性能优化方式比较简单且效果还不错！

### -------AQS---------

### 什么是AQS

- AQS 的全称为 AbstractQueuedSynchronizer ，**抽象队列同步器**。这个类在 java.util.concurrent.locks 包下面。
- AQS 就**是一个抽象类，主要用来构建锁和同步器。**
- AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。

### AQS的原理是什么？

AQS 核心思想是：

- **如果被请求的共享资源空闲，**
  - **则将当前请求资源的线程设置为有效的工作线程，**
  - **并且将共享资源设置为锁定状态**。
- 如果被请求的共享资**源被占用，**
  - **那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制**，
  - 这个机制 **AQS 是用 CLH 队列锁 实现的，即将暂时获取不到锁的线程加入到队列中。**
    - CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。**AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配**。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。

- AQS 使用 **int 成员变量 state 表示同步状态，**通过**内置的 线程等待队列 来完成获取资源线程的排队工作。**
  - **state 变量由 volatile 修饰，用于展示当前临界资源的获锁情况**
  - 另外，状态信息 state 可以通过 protected 类型的getState()、setState()和compareAndSetState() 进行操作。并且，这几个方法都是 final 修饰的，在子类中无法被重写。
- sync类是AQS的实现，AQS主要完成的任务
  - 同步状态的原子性管理
  - 线程的阻塞和解除阻塞
  - 管理队列


### AQS原理

AQS最核心的就是三大部分：

- 状态：state；
- 控制线程抢锁和配合的FIFO队列（双向链表）；
- 期望协作工具类去实现的获取/释放等重要方法（重写）。

状态state

- 这里state的具体含义，会根据具体实现类的不同而不同：比如在Semapore里，他表示剩余许可证的数量；在CountDownLatch里，它表示还需要倒数的数量；在ReentrantLock中，state用来表示“锁”的占有情况，包括可重入计数，当state的值为0的时候，标识该Lock不被任何线程所占有。
- **state是volatile修饰的，并被并发修改，所以修改state的方法都需要保证线程安全，比如getState、setState以及compareAndSetState操作来读取和更新这个状态。这些方法都依赖于unsafe类。**

FIFO队列

- 这个队列用来存放“等待的线程，AQS就是“排队管理器”，当多个线程争用同一把锁时，必须有排队机制将那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。
- AQS会维护一个等待的线程队列，把线程都放到这个队列里，这个队列是双向链表形式。

实现获取/释放等方法

- 这里的获取和释放方法，是利用AQS的协作工具类里最重要的方法，是由协作类自己去实现的，并且含义各不相同；
- **获取方法：获取操作会以来state变量，经常会阻塞（比如获取不到锁的时候）。在Semaphore中，获取就是acquire方法，作用是获取一个许可证； 而在CountDownLatch里面，获取就是await方法，作用是等待，直到倒数结束；**
- **释放方法：在Semaphore中，释放就是release方法，作用是释放一个许可证； 在CountDownLatch里面，获取就是countDown方法，作用是将倒数的数减一；**
- **需要每个实现类重写tryAcquire和tryRelease等方法。**
- 

### AQS资源共享方式

- AQS 定义两种资源共享方式：
  - **Exclusive（**独占，只有一个线程能执行，如**ReentrantLock**）
  - **Share**（共享，多个线程可同时执行，如**Semaphore/CountDownLatch**）。
- 一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。

### 自定义同步器

1. 使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。

2. 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

   1. AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：

      ```java
      //独占方式。尝试获取资源，成功则返回true，失败则返回false。
      protected boolean tryAcquire(int)
      //独占方式。尝试释放资源，成功则返回true，失败则返回false。
      protected boolean tryRelease(int)
      //共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
      protected int tryAcquireShared(int)
      //共享方式。尝试释放资源，成功则返回true，失败则返回false。
      protected boolean tryReleaseShared(int)
      //该线程是否正在独占资源。只有用到condition才需要去实现它。
      protected boolean isHeldExclusively()
      ```

   2. 什么是钩子方法呢？ 钩子方法是一种被声明在抽象类中的方法，一般使用 protected 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。

### Semaphore有什么用

synchronized 和 ReentrantLock 都是**一次只允许一个线程访问某个资源**，而Semaphore(信号量)可以用来**控制同时访问特定资源的线程数量。**当初始的资源个数为 1 的时候，Semaphore 退化为排他锁。

semaphore的两种模式

- 公平模式：调用 acquire() 方法的顺序就是获取许可证的顺序，遵循 FIFO
- 非公平模式；抢占式的

```java
public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}

public Semaphore(int permits, boolean fair) {
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}
```

**这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。**

Semaphore 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）

### Semaphore的原理是什么

- **Semaphore 是共享锁的一种实现，**它默认构造 AQS 的 state 值为 permits，你可以将 permits 的值理解为许可证的数量，只有拿到许可证的线程才能执行。
  - 调用semaphore.acquire() ，线程尝试获取许可证，如果 state >= 0 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 state 的值 state=state-1。如果 state<0 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。
  - 调用semaphore.release(); ，线程尝试释放许可证，并使用 CAS 操作去修改 state 的值 state=state+1。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 state 的值 state=state-1 ，如果 state>=0 则获取令牌成功，否则重新进入阻塞队列，挂起线程。

### CountDownLatch有什么用

CountDownLatch **允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕**。CountDownLatch 是一次性的，计数器的值**只能在构造方法中初始化一次**，之后没有任何机制再次对其设置值，当 CountDownLatch 使**用完毕后，它不能再次被使用。**

**CountDownLatch 的两种典型用法**：

1. **某一线程在开始运行前等待 n 个线程执行完毕 :** 将 `CountDownLatch` 的计数器初始化为 n （`new CountDownLatch(n)`），每当一个任务线程执行完毕，就将计数器减 1 （`countdownlatch.countDown()`），当计数器的值变为 0 时，在 `CountDownLatch 上 await()` 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。
2. **实现多个线程开始执行任务的最大并行性：注**意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 `CountDownLatch` 对象，将其计数器初始化为 1 （`new CountDownLatch(1)`），多个线程在开始执行任务前首先 `coundownlatch.await()`，当主线程调用 `countDown()` 时，计数器变为 0，多个线程同时被唤醒。

### CountDownLatch的原理是什么

CountDownLatch 是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用 countDown() 方法时,其实使用了tryReleaseShared方法以 CAS 的操作来减少 state,直至 state 为 0 。**当调用 await() 方法的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 方法就会一直阻塞，也就是说 await() 方法之后的语句不会被执行**。直到count 个线程调用了countDown()使 state 值被减为 0，或者调用await()的线程被中断，该线程才会从阻塞中被唤醒，await() 方法之后的语句得到执行

### 用过CountDownLatch吗？什么场景下用的？

1. 之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 CountDownLatch 。具体场景是下面这样的：
   **我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。**为此我们定义了一个线程池和 count 为 6 的CountDownLatch对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用CountDownLatch对象的 await()方法**，直到所有文件读取完之后，才会接着执行后面的逻辑。**
2. 可以使用 CompletableFuture 类来改进！Java8 的 CompletableFuture 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。
3. 上面的代码还可以继续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。

### CycliBarrier有什么用

CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。

- CountDownLatch 的实现是基于 AQS 的，而 CycliBarrier 是基于 ReentrantLock(ReentrantLock 也属于 AQS 同步器)和 Condition 的

## IO

### 基础知识总结

#### IO流简介

IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。
	Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流

#### 字节流

##### InputStream字节输入流

InputStream用于从源头（通常是**文件）读取数据**（字节信息）**到内存**中

- FileInputStream 是一个比较常用的字节输入流对象，可**直接指定文件路径**，可以**直接读取单字节数据**，也**可以读取至字节数组中**。
-  FileInputStream 通常会配合 **BufferedInputStream（字节缓冲输入流）**来使用。
-  DataInputStream 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 FileInputStream 。
-  ObjectInputStream 用于从输入流中读取 Java 对象（反序列化），ObjectOutputStream 用于将对象写入到输出流(序列化)。
-  另外，用于序列化和反序列化的类必须实现 Serializable 接口，对象中如果有属性不想被序列化，使用 transient 修饰。

##### OutputStream字节输出流

OutputStream用于**将数据（字节信息）写入到目的地（通常是文件）**，java.io.OutputStream抽象类是所有字节输出流的父类。

- FileOutputStream 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。
- 类似于 FileInputStream，FileOutputStream 通常也会配合 BufferedOutputStream（字节缓冲输出流，后文会讲到）来使用。
- DataOutputStream 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 FileOutputStream 。
- ObjectInputStream 用于从输入流中读取 Java 对象（ObjectInputStream,反序列化），ObjectOutputStream将对象写入到输出流(ObjectOutputStream，序列化)。

#### 字符流

不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 那为什么 I/O 流操作要分为字节流操作和字符流操作呢？

- 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。
- 如果我们不知道编码类型就很容易出现乱码问题。

##### Reader字符输入流

- Reader用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是所有字符输入流的父类。
- Reader 用于读取文本， InputStream 用于读取原始字节。
- InputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件。

##### Writer字符输出流

- Writer用于将数据（字符信息）写入到目的地（通常是文件），java.io.Writer抽象类是所有字符输出流的父类。
- OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装，可以直接将字符写入到文件。

#### 字节缓冲流

- IO 操作是很消耗性能**的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作**，提高流的传输效率。
- 字**节缓冲流这里采用了装饰器模式来增强 InputStream 和OutputStream子类对象的功能。**
- **字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 write(int b) 和 read() 这两个一次只读取一个字节的方法的时候。**由于**字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。**

##### BufferedInputStream字节缓冲输入流

- BufferedInputStream 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。
- BufferedInputStream 内部维护了一个缓冲区，**这个缓冲区实际就是一个字节数组**，通过阅读 BufferedInputStream 源码即可得到这个结论。

##### BufferOutputStream字节缓冲输出流

- BufferedOutputStream 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，**而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。**这样大幅减少了 IO 次数，提高了读取效率

#### 字符缓冲流

BufferedReader （字符缓冲输入流）和 BufferedWriter（字符缓冲输出流）类似于 BufferedInputStream（字节缓冲输入流）和BufferedOutputStream（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。

#### 打印流

- System.out 实际是用于获取一个 PrintStream 对象，print方法实际调用的是 PrintStream 对象的 write 方法。
- **PrintStream 属于字节打印流，与之对应的是 PrintWriter （字符打印流）。****PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类。**

#### 随机访问流

- 这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 RandomAccessFile 。
- RandomAccessFile 的构造方法如下，我们可以指定 mode（读写模式）。
  - r : 只读模式。
  - rw: 读写模式
  - rws: 相对于 rw，rws **同步更新对“文件的内容”或“元数据”的修改到外部存储设备。**
  - rwd : 相对于 rw，rwd **同步更新对“文件的内容”的修改到外部存储设备。**
- RandomAccessFile 比较常见的一个应用就是**实现大文件的 断点续传** 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。

### 设计模式总结

#### 装饰器模式

装饰器（Decorator）模式 可以在**不改变原有对象的情况下拓展其功能。**

- 对于字节流来说， FilterInputStream （对应输入流）和FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和OutputStream子类对象的功能。
  - 我们常见的BufferedInputStream(字节缓冲输入流)、DataInputStream 等等都是FilterInputStream 的子类，BufferedOutputStream（字节缓冲输出流）、DataOutputStream等等都是FilterOutputStream的子类。
  - ZipInputStream 和ZipOutputStream 还可以分别增强 BufferedInputStream 和 BufferedOutputStream 的能力。
- 对于字符流来说，BufferedReader 可以用来增加 Reader （字符输入流）子类的功能，BufferedWriter 可以用来增加 Writer （字符输出流）子类的功能。

装饰器模式很重要的一个特征，那就是可以**对原始类嵌套使用多个装饰器。**
为了实现这一效果，装饰器类**需要跟原始类继承相同的抽象类或者实现相同的接口**。上面介绍到的这些 IO 相关的装饰类和原始类**共同的父类是 InputStream 和OutputStream。**

#### 适配器模式

- 适配器（Adapter Pattern）模式 主要用于接口互不兼容的类的协调工作。
- 适配器分为对象适配器和类适配器**。类适配器使用继承关系来实现**，**对象适配器使用组合关系来实现**
- **IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准**确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。
- **InputStreamReader 和 OutputStreamWriter 就是两个适配器(Adapter)，** 同时，它们两个也是字节流和字符流之间的桥梁。InputStreamReader 使用 StreamDecoder （流解码器）对字节进行解码，实现字节流到字符流的转换， OutputStreamWriter 使用StreamEncoder（流编码器）对字符进行编码，实现字符流到字节流的转换。

适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。

#### 适配器和装饰器模式区别

- 装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。
- 适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 StreamDecoder （流解码器）和StreamEncoder（流编码器）就是分别基于 InputStream 和 OutputStream 来获取 FileChannel对象并调用对应的 read 方法和 write 方法进行字节数据的读取和写入。

#### 工厂模式

**工厂模式用于创建对象**，NIO 中大量用到了工厂模式，比如 Files 类的 newInputStream 方法用于创建 InputStream 对象（静态工厂）、 Paths 类的 get 方法创建 Path 对象（静态工厂）、ZipFileSystem 类（sun.nio包下的类，属于 java.nio 相关的一些内部实现）的 getPath 的方法创建 Path 对象（简单工厂）。

#### 观察者模式

- NIO 中的文件目录监听服务使用到了观察者模式。
- NIO 中的文件目录监听服务基于 WatchService 接口和 Watchable 接口。WatchService 属于观察者，Watchable 属于被观察者。
  - Watchable 接口定义了一个用于将对象注册到 WatchService（监控服务） 并绑定监听事件的方法 register 。
  - WatchService 用于监听文件目录的变化，同一个 WatchService 对象能够监听多个文件目录。
    - Path 类 register 方法的第二个参数 events （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。
- 常用的三种监听事件
  - StandardWatchEventKinds.ENTRY_CREATE：文件创建。
  - StandardWatchEventKinds.ENTRY_DELETE : 文件删除。
  - StandardWatchEventKinds.ENTRY_MODIFY : 文件修改。
- r**egister 方法返回 WatchKey 对象，通过WatchKey 对象可以获取事件的具体信息**比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。
- **WatchService 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化**

### IO模型详解

- 像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，**我们想要进行 IO 操作，一定是要依赖内核空间的能力。**
- **因此，用户进程想要执行 IO 操作的话，必须通过 系统调用 来间接访问内核空间**
- **我们在平常开发过程中接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）。**
- 从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。
- 当应用程序发起 I/O 调用后，会经历两个步骤：
  1. 内核等待 I/O 设备准备好数据
  2. 内核将数据从内核空间拷贝到用户空间

UNIX 系统下， IO 模型一共有 5 种：**同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。**

#### Java中3种常见的IO模型

- BIO

  同步阻塞 IO 模型中，应用程序发起 read 调用后，**会一直阻塞，直到内核把数据拷贝到用户空间。**

- NIO

  Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。

  - 同步非阻塞 IO 模型中，**应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。**
    - 但是，这种 IO 模型同样存在问题：应用程序**不断进行 I/O 系统调用轮询**数据是否已经准备好的过程是十分消耗 CPU 资源的。

  - IO 多路复用模型中，**线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。**read 调用的过程（数据从内核空间 -> 用户空间）还是阻塞的。
    - 目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。
    - Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

- AIO

  AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。

  **异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。**

### Java怎么实现网络IO高并发编程？

可以用 Java NIO ，是一种同步非阻塞的I/O模型，也是I/O多路复用的基础。NIO 是基于I/O多路复用实现的，它可以只用一个线程处理多个客户端I/O，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些。

### NIO核心知识总结

#### NIO是怎么实现的

- NIO是一种同步非阻塞的IO模型，所以也可以叫NON-BLOCKINGIO。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务。
- 同步的核心就Selector（I/O多路复用），Selector代替了线程本身轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当IO事件就绪时，可以通过写到缓冲区，保证IO的成功，而无需线程阻塞式地等待。
- NIO由一个专门的线程处理所有IO事件，并负责分发。事件驱动机制，事件到来的时候触发操作，不需要阻塞的监视事件。线程之间通过wait,notify通信，减少线程切换。
- NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。
- Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道

#### NIO核心组件

- **Buffer（缓冲区）**：**NIO 读写数据都是通过缓冲区进行操作的**。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。
- **Channel（通道）**：**Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。**通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。
- **Selector（选择器）**：**允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型**。所有的 Channel 都可以注册到 Selector 上，**由 Selector 来分配线程来处理事件**

##### Buffer缓冲区

- 在传统的 BIO 中，**数据的读写是面向流的， 分为字节流和字符流。**

- 在 Java 1.4 的 NIO 库中**，所有数据都是用缓冲区处理的**，这是新库和之前的 BIO 的一个重要区别，有点类似于 BIO 中的缓冲流。NIO 在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中。 使用 NIO 在读写数据时，都是通过缓冲区进行操作。

- ```java
  public abstract class Buffer {
      // Invariants: mark <= position <= limit <= capacity
      private int mark = -1;
      private int position = 0;
      private int limit;
      private int capacity;
  }
  ```

  容量（capacity）：Buffer可以存储的最大数据量，Buffer创建时设置且不可改变；
  界限（limit）：Buffer 中可以读/写数据的边界。写模式下，limit 代表最多能写入的数据，一般等于 capacity（可以通过limit(int newLimit)方法设置）；读模式下，limit 等于 Buffer 中实际写入的数据大小。
  位置（position）：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），position 都会归零，这样就可以从头开始读写了。
  标记（mark）：Buffer允许将位置直接定位到该标记处，这是一个可选属性；
  并且，上述变量满足如下的关系：0 <= mark <= position <= limit <= capacity 。

- **Buffer 有读模式和写模式这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。Buffer 被创建之后默认是写模式，调用 flip() 可以切换到读模式。如果要再次切换回写模式，可以调用 clear() 或者 compact() 方法。**

- Buffer 对象**不能通过 new 调用构造方法创建对象 ，只能通过静态方法实例化 Buffer。**

- 最常用的是 ByteBuffer，它可以用来存储和操作字节数据。你可以将 Buffer 理解为一个数组，IntBuffer、FloatBuffer、CharBuffer 等分别对应 int[]、float[]、char[] 等。

  - ```java
    ByteBuffer为例进行介绍：
    // 分配堆内存
    public static ByteBuffer allocate(int capacity);
    // 分配直接内存
    public static ByteBuffer allocateDirect(int capacity);
    ```

    Buffer 最核心的两个方法：
    	get : 读取缓冲区的数据
    	put ：向缓冲区写入数据
    除上述两个方法之外，其他的重要方法：
    	flip ：将缓冲区从写模式切换到读模式，它会将 limit 的值设置为当前 position 的值，将 position 的值设置为 0。
    	clear: 清空缓冲区，将缓冲区从读模式切换到写模式，并将 position 的值设置为 0，将 limit 的值设置为 capacity 的值。
    	……

##### Channel通道

- 通道与流的不同之处在于通道是双向的，它可以用于读、写或者同时用于读写。
- 因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。特别是在 UNIX 网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。
  - FileChannel：文件访问通道；
  - SocketChannel、ServerSocketChannel：TCP 通信通道；
  - DatagramChannel：UDP 通信通道；
- Channel 最核心的两个方法：
  - read ：读取数据并写入到 Buffer 中。
  - write ：将 Buffer 中的数据写入到 Channel 中。

##### Selector选择器

Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I/O 多路复用模型。

主要运作原理是：**通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时**，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，**这个 Channel 就处于就绪状态，会被 Selector 轮询出来。**Selector 会**将相关的 Channel 加入到就绪集合中**。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行相应的 I/O 操作。

一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 epoll() 代替传统的 select 实现，所以它并没有最大连接句柄 1024/2048 的限制。这也就意味着**只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端**

Selector 可以监听以下四种事件类型：

- SelectionKey.OP_ACCEPT：表示通道接受连接的事件，这通常用于 ServerSocketChannel。
- SelectionKey.OP_CONNECT：表示通道完成连接的事件，这通常用于 SocketChannel。
- SelectionKey.OP_READ：表示通道准备好进行读取的事件，即有数据可读。
- SelectionKey.OP_WRITE：表示通道准备好进行写入的事件，即可以写入数据。

一个 Selector 实例有三个 SelectionKey 集合：

- 所有的 SelectionKey 集合：代表了**注册在该 Selector 上的 Channel，**这个集合可以通过 keys() 方法返回。
- 被选择的 SelectionKey 集合：代表了**所有可通过 select() 方法获取的、需要进行 IO 处理的 Channel，**这个集合可以通过 selectedKeys() 返回。
- 被取消的 SelectionKey 集合：**代表了所有被取消注册关系的 Channel，**在下一次执行 select() 方法时，这些 Channel 对应的 SelectionKey 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。

#### 你知道有哪个框架用到NIO了吗？

Netty。

- Netty 的 I/O 模型是基于非阻塞 I/O 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 I/O， Proactor 采用异步 I/O。
- Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I/O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实

#### NIO零拷贝

零拷贝是指计算机执行 IO 操作时**，CPU 不需要将数据从一个存储区域复制到另一个存储区域，**从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： mmap+write、sendfile和 sendfile + DMA gather copy 。、

​							CPU 拷贝		DMA 拷贝	系统调用	上下文切换
传统方法 						2			 	2		read+write	4
mmap+write				          1				2		mmap+write	4
sendfile 						  1				2			sendfile	2
sendfile + DMA gather copy	        0				2			sendfile	2

Java 对零拷贝的支持：

- MappedByteBuffer 是 NIO 基于内存映射（mmap）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 mmap 系统调用。**它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。**
- FileChannel 的transferTo()/transferFrom()是 NIO 基于发送文件（sendfile）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 sendfile系统调用。**它可以直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区。**

## JVM

### 简介Java内存模型

- 元空间：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
- Java 虚拟机栈：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。
- 本地方法栈：与虚拟机栈类似，区别是虚拟机栈执行java方法，本地方法站执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。
- 程序计数器：程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。
- 堆内存：堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。堆是JVM内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例：所有的对象实例及数组都在对上进行分配。jdk1.8后，字符串常量池从永久代中剥离出来，存放在队中。
- 直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据

### Java内存区域详解

在虚拟机自动内存管理机制下， Java 程序员**把内存控制权利交给 Java 虚拟机**

#### 运行时数据区域

- JDK1.7 
  - 线程共享
    - 堆
      - 字符串常量池
    - 方法区
      - 运行时常量池
  - 线程私有
    - 虚拟机栈
    - 本地方法栈
    - 程序计数器
  - 本地内存-属于操作系统的本地内存，可以直接操作。
    - 直接内存
- JDK1.8
  - 线程共享
    - 堆
      - 字符串常量池
  - 线程私有不变
    - 虚拟机栈
    - 本地方法栈
    - 程序计数器
  - 本地内存
    - 直接内存
    - 元空间
      - 运行时常量池

##### 程序计数器

程序计数器主要有两个作用：

- 字节码解释器**通过改变程序计数器来依次读取指令，从而实现代码的流程控制**，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器**用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。**

⚠️ 注意：程序计数器是唯一一个**不会出现 OutOfMemoryError** 的内存区域**，它的生命周期随着线程的创建而创建，随着线程的结束而死亡**

##### Java虚拟机栈

- Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。
- **除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现**的（也需要和其他运行时数据区域比如程序计数器配合）。
- 方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
  - 每个栈帧中都拥有：**局部变量表、操作数栈、动态链接、方法返回地址**
    - 局部变量表
      - **存放了编译期可知的各种数据类型**
        （boolean、byte、char、short、int、float、long、double）、
      - **对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用**指针**，也可能是指向一个代表对象的**句柄**或其他与此对象相关的位置）。
    - 操作数栈
      - 主要作为方法调用的中转站使用，用于**存放方法执行过程中产生的中间计算结果。**
      - 另外，计算过程中**产生的临时变量也**会放在操作数栈中。
    - 动态链接
      - Class 文件的常量池里保存有大量的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用
      - 动态链接的作用就是为了**将符号引用转换为调用方法的直接引用，**这个过程也被称为 动态连接 。
    - 方法返回地址
- 简单总结一下程序运行中栈可能会出现两种错误：
  - StackOverFlowError： 若栈的内存大小**不允许动态扩展**，那么当线程请求栈的深度超过当前 Java 虚拟机栈的**最大深度**的时候，就抛出 StackOverFlowError 错误。
  - OutOfMemoryError： 如果栈的内存大小**可以动态扩展**， 如果虚拟机在动态扩展栈时**无法申请到足够的内存空间**，则抛出OutOfMemoryError异常。

##### 本地方法栈

虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而**本地方法栈则为虚拟机使用到的 Native 方法服务**。在 **HotSpot 虚拟机中和 Java 虚拟机栈合二为一。**

##### 堆

在**虚拟机启动时创建**。此内存区域的唯一目的就是**存放对象实例**，**几乎**所有的对象实例以及数组都在这里分配内存

- 从 JDK 1.7 开始已经默认开启逃逸分析，**如果某些方法中的对象引用没有被返回或者未被外面使用（**也就是未逃逸出去），那么**对象可以直接在栈上分配内存。**

Java 堆是**垃圾收集器管理的主要区域**，因此也被称作 **GC 堆（Garbage Collected Heap）**

- 由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆还可以细分为：**新生代和老年代；**再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是**更好地回收内存，或者更快地分配内存。**

- JDk7及以前，堆内存被分配为以下部分
  - **新生代内存(Young Generation)**
    - **eden**
    
      在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）
    
    - **survivor**
    
      在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。
    
      在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。
    
  - **老生代(Old Generation)（15岁之后）**
  
    存放过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。
  
  - **永久代(Permanent Generation)**
  
- JDK 8 版本之后 **PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。**

  元空间用于存储类的元数据信息，如类的结构信息（如字段、方法信息等）。元空间并不在Java堆中，而是使用本地内存，这解决了永久代容易出现的内存溢出问题。

- 大对象区（Large Object Space / Humongous Objects）:在某些JVM实现中（如G1垃圾收集器），为大对象分配了专门的区域，称为大对象区或Humongous Objects区域。大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。

###### 字符串常量池

字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

JDK 1.7 为什么要将字符串常量池移动到堆中？

主要是因为**永久代（方法区实现）的 GC 回收效率太低**，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，**将字符串常量池放到堆中，能够更高效及时地回收字符串内存。**

##### 方法区

当虚拟机要使用一个类时，它需要**读取并解析 Class 文件获取相关信息，再将信息存入到方法区。**方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。

- **类信息：**包括类的结构信息、类的访问修饰符、父类与接口等信息。
- **常量池**：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。
- **静态变量**：存储类的静态变量，这些变量在类初始化的时候被赋值。
- **方法字节码**：存储类的方法字节码，即编译后的代码。
- **符号引用**：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。
- **运行时常量池**：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。
- **常量池缓**存：用于提升类加载的效率，将常用的常量缓存起来方便使用

- **永久代以及元空间**是 HotSpot 虚拟机对虚拟**机规范中方法区**的两种实现方式
- 并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。
  - 整个**永久代有一个 JVM 本身设置的固定大小上限，无法进行调整**（也就是受到 JVM 内存的限制），而元空间**使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。**
  - **元空间里面存放的是类的元数据**，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由**系统的实际可用空间来控制，这样能加载的类就更多了。**
  - 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。
  - **永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。**

###### 运行时常量池

Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于**存放编译期生成的**各种**字面量**（Literal）和**符号引用**（Symbolic Reference）的 **常量池表**(Constant Pool Table) 。

常量池表会在类加载后存放到方法区的运行时常量池中.

##### 直接内存

直接内存**是一种特殊的内存缓冲区**，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。

#### Java内存模型里的堆和栈有什么区别？

- 用途**：栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据。**每当一个方法被调用，一个栈帧（stack frame）就会在栈中创建，用于存储该方法的信息，当方法执行完毕，栈帧也会被移除。堆**用于存储对象的实例（包括类的实例和数组）。**当你使用new关键字创建一个对象时，对象的实例就会在堆上分配空间。
- 生命周期：栈中的数据具有确定的生命周期，**当一个方法调用结束时，其对应的栈帧就会被销毁，栈中存储的局部变量也会随之消失**。堆**中的对象生命周期不确定，对象会在垃圾回收机制（Garbage Collection, GC）检测到对象不再被引用时才被回收。**
- 存取速度：**栈的存取速度通常比堆快，因为栈遵循先进后出**（LIFO, Last In First Out）的原则，操作简单快速。堆的存取速度相对较慢，因为对象在堆上的分配和回收需要更多的时间，而**且垃圾回收机制的运行也会影响性能。**
- 存储空间：**栈的空间相对较小，且固定，由操作系统管理。当栈溢出时，通常是因为递归过深或局部变量过大**。堆的**空间较大，动态扩展，由JVM管理。**堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象。
- 可见性：**栈中的数据对线程是私有的**，每个线程有自己的栈空间。**堆中的数据对线程是共享的**，所有线程都可以访问堆上的对象

#### 栈中存放的是对象还是指针？

- 在JVM内存模型中，栈（Stack）主要用于管理线程的局部变量和方法调用的上下文，而堆（Heap）则是用于存储所有类的实例和数组。
- 当我们在栈中讨论“存储”时，实际上指的是存储基本类型的数据（如int, double等）和对象的引用，而不是对象本身。
- 这里的关键点是，栈中存储的不是对象，而是对象的引用。也就是说，当你在方法中声明一个对象，比如MyObject obj = new MyObject();，这里的obj实际上是一个存储在栈上的引用，指向堆中实际的对象实例。这个引用是一个固定大小的数据（例如在64位系统上是8字节），它指向堆中分配给对象的内存区域 

#### 方法区中的方法的执行过程

1. **解析方法调用**：JVM会**根据方法的符号引用找到实际的方法地址**（如果之前没有解析过的话）。
2. **栈帧创建**：在调用一个方法前，**JVM会在当前线程的Java虚拟机栈中为该方法分配一个新的栈帧**，用于**存储局部变量表、操作数栈、动态链接、方法出口等信息。**
3. **执行方法**：执行方法内的字节码指令，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等。
4. **返回处理**：方法执行完毕后，可能会返回一个结果给调用者，并清理当前栈帧，恢复调用者的执行环境

#### 内存泄漏和内存溢出的理解？

##### 内存泄漏

内存泄漏是指**程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少。**虽然在Java中，垃圾回收机制会自动回收不再使用的对象，**但如果有对象仍被不再使用的引用持有，垃圾收集器无法回收这些内存，最终可能导致程序的内存使用不断增加。**

内存泄漏常见原因?

- 静态集合：**使用静态数据结构（如HashMap或ArrayList）存储对象，且未清理。**
- 事件监听：**未取消对事件源的监听，导致对象持续被引用**。
- 线程：**未停止的线程可能持有对象引用，无法被回收。**

##### 内存溢出

内存溢出是指Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发OutOfMemoryError。这通常**发生在堆内存不足以存放新创建的对象时。**

内存溢出常见原因？

- **大量对象创建**：程序中不断创建大量对象，超出JVM堆的限制。
- **持久引**用：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。
- **递归调用**：深度递归导致栈溢出

#### jvm内存结构有哪几种内存溢出的情况

- **堆内存溢出：**当出现java.lang.OutOfMemoryError:Java heap space异常时，就是堆内存溢出了。原因是**代码中可能存在大对象分配，或者发生了内存泄露，**导致**在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。**
- **栈溢出**：如果我们写一段程序**不断的进行递归调用**，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。
- **元空间溢出：**元空间的溢出，系统会抛出java.lang.OutOfMemoryError: Metaspace。出现这个异常的问题的原因是**系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法，**导致元空间的内存占用很大。
- **直接内存内存溢出**：在使用ByteBuffer中的allocateDirect()的时候会用到，很多javaNIO(像netty)的框架中被封装为其他的方法，出现该问题时会抛出java.lang.OutOfMemoryError: Direct buffer memory异常。

#### 有具体的内存泄漏和内存溢出的例子么请举例及解决方案?

1. 静态属性导致内存泄漏

   会导致内存泄露的一种情况就是大量使用static静态变量。在Java中，静态属性的生命周期通常伴随着应用整个生命周期（除非ClassLoader符合垃圾回收的条件）。下面来看一个具体的会导致内存泄露的实例：

   ```java
   public class StaticTest {
   public static List<Double> list = new ArrayList<>();
   public void populateList() {
   for (int i = 0; i < 10000000; i++) {
   list.add(Math.random());
   }
   Log.info("Debug Point 2");
   }
   public static void main(String[] args) {
   Log.info("Debug Point 1");
   new StaticTest().populateList();
   Log.info("Debug Point 3");
   }
   }
   ```

   如果监控内存堆内存的变化，会发现在打印Point1和Point2之间，堆内存会有一个明显的增长趋势图。但当执行完populateList方法之后，对堆内存并没有被垃圾回收器进行回收。

   但针对上述程序，如果将定义list的变量前的static关键字去掉，再次执行程序，会发现内存发生了具体的变化

   程序执行的前半部分内存使用情况都一样，但当执行完populateList方法之后，后者不再有引用指向对应的数据，垃圾回收器便进行了回收操作。因此，我们要十分留意static的变量，**如果集合或大量的对象定义为static的，它们会停留在整个应用程序的生命周期当中。而它们所占用的内存空间，本可以用于其他地方。**

   

   如何优化：

   1. 尽量减少静态便能量
   2. 如果使用单例，尽量采用懒汉加载

   

2. 未关闭的资源

   无论什么时候当我们创建一个连接或打开一个流，JVM都会分配内存给这些资源。比如，数据库链接、输入流和session对象。

   **忘记关闭这些资源，会阻塞内存，从而导致GC无法进行清理。**特别是当程序发生异常时，没有在finally中进行资源关闭的情况。这些未正常关闭的连接，如果不进行处理，轻则影响程序性能，重则导致OutOfMemoryError异常发生。

   如果进行处理呢：

    1. 始终记得**在finally中进行资源的关闭**

    2. **关闭连接的自身代码不能发生异常；**

    3. Java7以上版本**使用try-with-resources代码方式进行资源关闭。**

       

3. 使用ThreadLocal

   ThreadLocal提**供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同**。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定，从而实现线程安全的特性。

   ThreadLocal的实现中，每个Thread维护一个ThreadLocalMap映射表，key是ThreadLocal实例本身，value是真正需要存储的Object。

   ![image-20241010091411720](D:\2024\Notes\Typora\八股\Java.assets\image-20241010091411720.png)

   ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。

   **如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value永远无法回收，造成内存泄漏。**

   如何解决此问题？

   1. **使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除**；
   2. 不要使用ThreadLocal.set(null) 的方式清除value，它实际上并没有清除值，**而是查找与当前线程关联的Map并将键值对分别设置为当前线程和null。**
   3. 最好**将ThreadLocal视为需要在finally块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源。**

#### HotSpot虚拟机对象探秘

##### 对象的创建

###### 1. 类加载检查

- 虚拟机**遇到一条 new 指令**时，
- 首先将去**检查这个指令的参数**是否能在**常量池中定位到这个类的符号引用**，
- 并且检查这个**符号引用代表的类是否已被加载过、解析和初始化过**。
- 如果没有，那必须**先执行相应的类加载过程**

###### 2. 分配内存

- 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。
- **对象所需的内存大小在类加载完成后便可确定**，为对象**分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**
- 分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方**式由 Java 堆是否规整决定，**而 Java 堆是否规整**又由所采用的垃圾收集器是否带有压缩整理功能决定。**
  - 指针碰撞
    - 适用场合：堆内存**规整（**即没有内存碎片）的情况下。
    - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，**中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。**
    - 使用该分配方式的 GC 收集器：Serial, ParNew
  - 空闲列表
    - 适用场合：堆内**存不规整**的情况下。
    - 原理：虚拟机**会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。**
    - 使用该分配方式的 GC 收集器：CMS
- 内存并发分配问题
  - CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
  - TLAB： 为每一个线程预先在 Eden 区分配一块儿内存**，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配**

###### 3. 初始化零值

内存分配完成后，**虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）**，这一步操作保证了对象的实例字段在 Java 代码中**可以不赋初始值就直接使用**，程序能访问到这些字段的数据类型所对应的零值。

###### 4. 设置对象头

**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 **另外，根据虚拟机当前运行状态的不同，**如是否启用偏向锁等**，对象头会有不同的设置方式。**

###### 5. 执行init方法

从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说**，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。**

##### 对象的生命周期

对象的生命周期包括创建、使用和销毁三个阶段：

1. 创建：对象通过关键字new在堆内存中被实例化，构造函数被调用，对象的内存空间被分配。
2. 使用：对象被引用并执行相应的操作，可以通过引用访问对象的属性和方法，在程序运行过程中被不断使用。
3. 销毁：当对象不再被引用时，通过垃圾回收机制自动回收对象所占用的内存空间。垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。

##### 对象的内存布局

HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：

- 对象头（Header）
  - **标记字段（Mark Word）：用于存储对象自身的运行时数据**， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等
  - **类型指针（Klass Word）**：对象指向它的类元数据的指针，虚拟机通过这个指针**来确定这个对象是哪个类的实例。**
- 实例数据（Instance Data）
  - **实例数据部分是对象真正存储的有效信息，**也是在程序中所定义的各种类型的字段内容
- 对齐填充（Padding）
  - 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。8字节补齐

##### 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄、直接指针。**

- 使用句柄

  Java **堆中将会划分出一块内存来作为句柄池**，reference 中存储的就是对象的**句柄地址**，而句柄中**包含了对象实例数据与对象类型数据各自的具体地址信息。**

  使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在**对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改**

- 直接指针

  reference 中存储的直接就是对象的地址。

  使用直接指针访问方式最大的好处就是**速度快**，它节省了一次指针定位的时间开销。

### JVM垃圾回收详解

####  什么是Java里面的垃圾回收  

**垃圾回收（Garbage Collection, GC）是自动管理内存的一种机制，**它**负责自动释放不再被程序引用的对象所占用的内存，**这种机制减少了内存泄漏和内存管理错误的可能性。垃圾回收可以通过多种方式触发，具体如下：

- **内存不足时：**当JVM检测到堆内存不足，无法为新的对象分配内存时，会自动触发垃圾回收。
- **手动请求：**虽然垃圾回收是自动的，开发者可以通过调用 System.gc() 或 Runtime.getRuntime().gc() 建议 JVM 进行垃圾回收。不过这只是一个建议，并不能保证立即执行。
- JVM参数：启动 Java 应用时可以**通过 JVM 参数来调整垃圾回收的行为，**比如：-Xmx（最大堆大小）、-Xms（初始堆大小）等。
- **对象数量或内存使用达到阈值**：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收

#### GC只会对堆进行GC吗？

JVM 的垃圾回收器不仅仅会对堆进行垃圾回收，它还会对方法区进行垃圾回收。

- 堆（Heap）： 堆是用于存储对象实例的内存区域。大部分的垃圾回收工作都发生在堆上，**因为大多数对象都会被分配在堆上**，而垃圾回收的重点通常也是回收堆中不再被引用的对象，以释放内存空间。
- 方法区（Method Area）： 方法区是用于存储类信息、常量、静态变量等数据的区域。**虽然方法区中的垃圾回收与堆有所不同，但是同样存在对不再需要的常量、无用的类信息等进行清理的过程。**

#### 堆空间的基本结构

Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配，最核心的功能是 堆 内存中对象的分配与回收。Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。

从垃圾回收的角度来说，由于现在收集器基本都采用**分代垃圾收集算**法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

- 新生代内存(Young Generation)
- 老生代(Old Generation)
- 永久代(Permanent Generation)

#### 内存分配和回收原则

##### 1. 对象优先在Eden区分配

当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。可以执行如下代码验证：

##### 2. 大对象直接进入老年代

大对象就是需要大量连续内存空间的对象。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。

##### 3. 长期存活的对象将进入老年代

既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。

##### 4. 主要进行gc的区域

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

1. 部分收集 (Partial GC)：
   1. 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
   2. 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
   3. 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
2. 整堆收集 (Full GC)：收集整个 Java 堆和方法区

##### 5. 空间分配担保

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

#### 死亡对象判断方法？new出的对象什么时候能回收

##### 1. 引用计数法

给对象中添加一个引用计数器：

- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的

这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它**很难解决对象之间循环引用的问题。**

##### 2. 可达性分析算法

通过一系列的称为 **“GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。**

GCRoot

1. 虚拟机栈中正在引用的对象
2. 本地方法栈中正在引用的对象
3. 静态属性引用的对象
4. 方法区常量引用的对象

##### 3. 终结器

如果对象重写了finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题



###### 哪些对象可以作为GC Roots呢

- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- JNI（Java Native Interface）引用的对象

##### 引用类型总结

1. 强引用

   强引用指的就是代码中普遍存在的赋值方式，比如A a = new A()这种

   ​	如果一个对象具有强引用，垃圾回收器绝不会回收它。**当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收**具有强引用的对象来解决内存不足问题。

2. 软引用

   软引用可以用SoftReference来描述，指那些有用但是不是必须要的对象。

   ​	如果内存空间足够，垃圾回收器就不会回收它，**如果内存空间不足了，就会回收这些对象的内存。**只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
   ​	**软引用可以和一个引用队列（ReferenceQueue）联合使用，**如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会**把这个软引用加入到与之关联的引用队列中**。

3. 弱引用

   弱引用可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。

   ​	和软引用基本一样，区别是**只具有弱引用的对象拥有更短暂的生命周期**。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，**不管当前内存空间足够与否，都会回收它的内存。**不过，由于垃圾回收器是一个**优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。**

4. 虚引用

   虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存

   ​	虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**虚引用主要用来跟踪对象被垃圾回收的活动**。

   ​	虚引用与软引用和弱引用的一个区别在于： **虚引用必须和引用队列（ReferenceQueue）联合使用。**当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，**就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中**。程序**可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收**。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

   ​	很少使用弱引用与虚引用**，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**

##### 详细讲讲弱引用

弱引用是一种引用类型，它不会阻止一个对象被垃圾回收。

在Java中，弱引用是通过java.lang.ref.WeakReference类实现的。弱引用的一个主要用途是**创建非强制性的对象引用，这些引用可以在内存压力大时被垃圾回收器清理，从而避免内存泄露。**

弱引用的使用场景：

- **缓存系统：**弱引用常用于实现缓存，特别是当希望缓存项能够在内存压力下自动释放时。如果缓存的大小不受控制，可能会导致内存溢出。使用弱引用来维护缓存，可以让JVM在需要更多内存时自动清理这些缓存对象。
- **对象池：在对象池中，弱引用可以用来管理那些暂时不使用的对象。**当对象不再被强引用时，它们可以被垃圾回收，释放内存。
- **避免内存泄露：**当一个对象不应该被长期引用时，使用弱引用可以防止该对象被意外地保留，从而避免潜在的内存泄露。

如果一个对象被垃圾回收，下次**尝试从缓存中获取时，get()方法会返回null，这时我们可以重新创建对象并将其放入缓存中**。因此，使用弱引用时要注意，一旦对象被垃圾回收，通过弱引用获取的对象可能会变为null，因此在使用前通常需要检查这一点。

##### 如何判断一个常量是废弃常量

假如**在字符串常量池中**存在字符串 "abc"，如果当前**没有任何 String 对象引用该字符串常量的话**，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了	

##### 如何判断一个类是无用的类

- 该类**所有的实例都已经被回收**，也就是 Java 堆中不存在该类的任何实例。

- **加载该类的 ClassLoader 已经被回收。**

- 该类对应的 java.lang.Class 对**象没有在任何地方被引用**，**无法在任何地方通过反射访问该类的方法**。

  虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收

#### 垃圾收集方法

##### 1. 标记-清除算法

标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先通过可达性分析，**标记出所有需要回收的对象，然后统一回收所有被标记的对象。**

- 效率问题：标记和清除两个过程**效率都不高。**
- 空间问题：标记清除后**会产生大量不连续的内存碎片。**

##### 2. 复制算法

为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。**当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。**这样就使每次的内存回收都是对内存区间的一半进行回收。

- **可用内存变小**：可用内存缩小为原来的一半。
- **不适合老年代：**如果存活对象数量比较大，复制性能会变得很差。

##### 3. 标记-整理算法

标记-整理（Mark-and-Compact）算法是**根据老年代的特点提出的一种标记算法**，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是**让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。**

##### 4. 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，**只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。**

比如**在新生代中，每次收集都会有大量对象死去，所以可以选择“复制”算法**，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而**老年代的对象存活几率是比较高的**，而且没有额外的空间对它进行分配担保，所以我们必须选择“**标记-清除”或“标记-整理”算法进行垃圾收集。**

#### 垃圾回收算法哪些阶段会stop the world

标记-复制算法**应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。**标记-复制算法可以分为三个阶段：

- 标记阶段，即从GC Roots集合开始，**标记活跃对象；**
- 转移阶段，即把**活跃对象复制到新**的内存地址上；
- 重定位阶段，因为转移导致对象的地址发生了变化，在**重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。**

下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：

![image-20241010102659574](D:\2024\Notes\Typora\八股\Java.assets\image-20241010102659574.png)

G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。

**标记阶段停顿分析**

- **初始标记阶段：**初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。
- 并发标记阶段：**并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。**
- 再标记阶段：**重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。**

**清理阶段停顿分析**

清理阶段**清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的**。

**复制阶段停顿分析**

复制算法中的转移阶段需要分配新内存和复制对象的成员变量。**转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。**对象越复杂，复制耗时越长。

四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。**转移阶段要处理所有存活的对象，耗时会较长。**

**因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW**

#### minorGC、majorGC、fullGC的区别，什么场景触发fullGC

在Java中，垃圾回收机制是自动管理内存的重要组成部分。根据其作用范围和触发条件的不同，可以将GC分为三种类型：Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC。以下是这三种GC的区别和触发场景：

- Minor GC (Young GC)
  - 作用范围：只**针对年轻代进行回收，包括Eden区和两个Survivor区（S0和S1）。**
  - 触发条件：**当Eden区空间不足时，JVM会触发一次Minor GC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代（Old Generation）**。
  - 特点：通常发生得非常频繁，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。
- Major GC
  - 作用范围：**主要针对老年代进行回收，但不一定只回收老年代**。
  - 触发条件：当老年代空间不足时，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major GC。
  - 特点：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。
- Full GC
  - 作用范围：**对整个堆内存（包括年轻代、老年代以及永久代/元空间）进行回收。**
  - 触发条件：
    - **直接调用System.gc()或Runtime.getRuntime().gc()方法时，虽然不能保证立即执行，但JVM会尝试执行Full GC。**
    - Minor GC（新生代垃圾回收）时**，如果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象，则会触发Full GC，对整个堆内存进行回收。**
    - **当永久代（Java 8之前的版本）或元空间（Java 8及以后的版本）空间不足时**。
  - 特点：Full GC是最昂贵的操作，因为它需要停止所有的工作线程（Stop The World），遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少Full GC的触发

#### 垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现

JDK 默认垃圾收集器（使用 java -XX:+PrintCommandLineFlags -version 命令查看）：

- JDK 8: Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK22: G1

![image-20241010094611051](D:\2024\Notes\Typora\八股\Java.assets\image-20241010094611051.png)

##### Serial收集器-串行收集器

- 的“单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有
- **新生代标记复制 老年代标记整理**

##### ParNew收集器

- ParNew 收集器其实就是 Serial 收集器的多线程版本
- **新生代标记复制 老年代标记整理**

##### Parallel Scavenge收集器

- Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器
- **新生代标记复制 老年代标记整理**

##### Serial Old收集器

##### Parallel Old 收集器

##### CMS收集器

- CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。
- CMS 收集器是一种 “标记-清除”算法实现的，
- 主要优点：**并发收集、低停顿。**
- 但是它有下面三个明显的缺点：
  **对 CPU 资源敏感；**
  **无法处理浮动垃圾；**
  它使用的回收算法-“标记-清除”算法会导致收集结束时会有**大量空间碎片产生**

##### **G1收集器**

- **G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**
- G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，**优先选择回收价值最大的 Region(**这也就是它的名字 Garbage-First 的由来) 。这种**使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。**

##### G1回收器的特色是什么？

G1 的特点：

- G1最大的特点是引入分区的思路，弱化了分代的概念。
- 合理利用垃圾收集各个周期的资源，解决了其他收集器、甚至 CMS 的众多缺陷

G1 相比较 CMS 的改进：

- 算法： G1 基于标记--整理算法, 不会产生空间碎片，在分配大对象时，不会因无法得到连续的空间，而提前触发一次 FULL GC 。
- 停顿时间可控： G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。
- 并行与并发：G1 能更充分的利用 CPU 多核环境下的硬件优势，来缩短 stop the world 的停顿时间

详细讲讲？

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集：**虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清除”算法不同，G**1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。**
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

##### CMS和G1区别？

1. 区别一：使用的范围不一样：

   **CMS收集器是老年代的收集器，**可以配合新生代的Serial和ParNew收集器一起使用

   **G1收集器收集范围是老年代和新生代。**不需要结合其他收集器使用

2. 区别二：STW的时间：

   **CMS收集器以最小的停顿时间为目标的收集器**。

   **G1收集器可预测垃圾回收 (opens new window)的停顿时间**（建立可预测的停顿时间模型）

3. 区别三： 垃圾碎片

   CMS收集器是使用“**标记-清除”算法进行的垃圾回收，容易产生内存碎片**

   G1收集器使用的是“**标记-整理”算法，进行了空间整合，没有内存空间碎**片。

4. 区别四： **垃圾回收的过程不一样**

   <img src="D:\2024\Notes\Typora\八股\Java.assets\image-20241010104154938.png" alt="image-20241010104154938" style="zoom:50%;" />

5. 区别五: CMS会产生浮动垃圾
   **CMS产生浮动垃圾过多时会退化为serial old**，效率低，因为在上图的第四阶段，CMS清除垃圾时是并发清除的，这个时候，垃圾回收线程和用户**线程同时工作会产生浮动垃圾，也**就意味着CMS垃圾回收器必须预留一部分内存空间用于存放浮动垃圾
   而G1没有浮动垃圾，**G1的筛选回收是多个垃圾回收线程并行gc的，没有浮动垃圾的回收，在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收**。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式

##### 什么情况下使用CMS和G1

**CMS适用场景：**

- **低延迟需求：适用于对停顿时间要求敏感**的应用程序。
- **老生代收集**：主要针对老年代的垃圾回收。
- **碎片化管理**：容易出现内存碎片，可能需要定期进行Full GC来压缩内存空间。

**G1适用场景：**

- **大堆内存：**适用于需要管理大内存堆的场景，能够有效处理数GB以上的堆内存。
- **对内存碎片敏**感：G1通过紧凑整理来减少内存碎片，降低了碎片化对性能的影响。
- **比较平衡的性能**：G1在提供较低停顿时间的同时，也保持了相对较高的吞吐量。

##### ZGC收集器

与 CMS 中的 ParNew 和 G1 类似**，ZGC 也采用标记-复制算法，**不过 ZGC 对该算法做了重大改进。
**ZGC 可以将暂停时间控制在几毫秒以内**，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但**代价是牺牲了一些吞吐量。**ZGC 最大支持 16TB 的堆内存。

### 类文件结构详解

#### 回顾字节码

- **JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件）**，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，**由于字节码并不针对一种特定的机器**，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。
- **.class文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因**

#### Class文件结构总结

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口数量
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//字段数量
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

使用 **jclasslib** 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。

1. 魔数 magic number

   每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件

2. Class文件版本号 minor&major version

3. 常量池 constant pool

   常量池的数量是 constant_pool_count-1（常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”）。

   常量池存放两大常量

   1. 字面量（文本字符串、声明为final的常量值）
   2. 符号引用
      1. 类和接口全限定名
      2. 字段的名称和描述符
      3. 方法的名称和描述符

4. 访问标志 access Flags

   在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。

5. 当前类、父类、接口索引集合

   Java 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，

6. 字段表集合 fields

   字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。

7. 方法表集合 methods

   Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。

8. 属性表集合 attributes

   在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。

### 类加载过程详解

#### 类的生命周期

- 加载
- 连接
  - 验证
  - 准备
  - 解析
- 初始化
- 使用
- 卸载

#### 类加载过程

##### 加载

1. **通过全类名获取定义此类的二进制字节流。**
2. **将字节流所代表的静态存储结构转换为方法区的运行时数据结构。**
3. 在**内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。**

加载这一步主要是通过我们后面要讲到的 **类加载器** 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是**哪个类加载器加载由 双亲委派模型 决定**

##### 验证

验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

1. **文件格式验证**（Class 文件格式检查）
2. **元数据验证**（字节码语义检查）
3. **字节码验证**（程序语义检查）
4. **符号引用验证**（类的正确性检查）

##### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段

##### 解析

解析阶段是虚拟机将常量池内的**符号引用替换为直接引用的**过程

##### 初始化

初始化阶段是执行初始化方法 <clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

#### 类卸载

卸载类即该类的 Class 对象被 GC。
卸载类需要满足 3 个要求:

- 该类的**所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。**
- 该类**没有在其他任何地方被引用**
- 该类的类加载器的**实例已被 GC**

所以，在 JVM 生命周期内**，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。**

### 类加载器详解

#### 类加载器

##### 类加载器介绍

类加载器的主要作用是**加载 Java 类的字节码（ .class 文件）到 JVM 中（**在内存中生成一个代表该类的 Class 对象）。

- 类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。
- **每个 Java 类都有一个引用指向加载它的 ClassLoader。**
- **数组类不是通过 ClassLoader 创建的**（数组类没有对应的二进制字节流），**是由 JVM 直接生成**

##### 类加载器加载规则

- JVM 启动的时候，并不会一次性加载所有的类，**而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。**
- 对于已经加载的类会被放在 ClassLoader 中。在类加载的时候，系统**会首先判断当前类是否被加载过**。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。

##### 类加载器总结

- **BootstrapClassLoader(启动类加载器)：**最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要**用来加载 JDK 内部的核心类库**（ %JAVA_HOME%/lib目录下的 rt.jar、resources.jar、charsets.jar等 jar 包和类）以及被 -Xbootclasspath参数指定的路径下的所有类。
- **ExtensionClassLoader(扩展类加载器)**：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类。
- **SystemClassLoader系统类加载器/AppClassLoader(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。
- 用户自定义类加载器

> 这些类加载器之间的关系形成了**双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。**
> 只有**当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载**

除了 BootstrapClassLoader 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 ClassLoader抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。

为什么 获取到 ClassLoader 为null就是 BootstrapClassLoader 加载的呢？ 这是因为BootstrapClassLoader 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。

##### 自定义类加载器

- 除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader抽象类。
- ClassLoader 类有两个关键的方法：
  - protected Class loadClass(String name, boolean resolve)：**加载指定二进制名称的类，实现了双亲委派机制** 。name 为类的二进制名称，resolve 如果为 true，在加载时调用 resolveClass(Class<?> c) 方法解析该类。
  - protected Class findClass(String name)：根据类的二进制名称来查找类，默认实现是空方法。
  - 如果我们不**想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可**，无法被父类加载器加载的类最终会通过这个方法被加载。但是，**如果想打破双亲委派模型则需要重写 loadClass()** 方法。

#### 双亲委派模型

##### 双亲委派模型介绍

- ClassLoader 类使用委托模型来搜索类和资源。
- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
- ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

​		**自顶向下尝试加载类、自底向上查找判断类是否被加载**

- 类加载器之间的父子关系一般不是以继承的关系来实现的，而是**通常使用组合关系来复用父加载器的代码。**
- 在面向对象编程中，有一条非常经典的设计原则：**组合优于继承，多用组合少用继承**

##### 执行流程

1. 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
2. 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。
3. 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 findClass() 方法来加载类）。
4. 如果子类加载器也无法加载这个类，那么它会抛出一个 ClassNotFoundException 异常

JVM 判定两个 Java 类是否相同的具体规则：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。

##### 好处

1. **保证类的唯一性：**通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，**保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。**
2. **保证安全性**：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以**防止不可信的类假冒核心类**，增强了系统的安全性。例如，恶意代码无法自定义一个java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。
3. **支持隔离和层次划分**：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。
4. **简化了加载流程**：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率

##### 打破双亲委派模型方法

**如果想打破双亲委派模型则需要重写父类 loadClass()** 方法。

### 最重要的JVM参数总结

#### 堆内存相关

##### 显式指定堆内存-xms和-xmx

##### 显式新生代内存

1. 通过-XX:NewSize和-XX:MaxNewSize指定
2. 通过-Xmn<young size>[unit]指定

##### 显式指定永久代/元空间的大小

1. jdk1.8以前

   -XX:PermSize=N #方法区 (永久代) 初始大小
   -XX:MaxPermSize=N #方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen

2. 以后

   -XX:MetaspaceSize=N #设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）
   -XX:MaxMetaspaceSize=N #设置 Metaspace 的最大大小

#### 垃圾收集相关

##### 垃圾回收器

1. 串行垃圾收集器

2. 并行垃圾收集器

3. CMS 垃圾收集器

4. G1 垃圾收集器

   -XX:+UseSerialGC
   -XX:+UseParallelGC
   -XX:+UseConcMarkSweepGC
   -XX:+UseG1GC

GC日志记录

```java
# 必选
# 打印基本 GC 信息
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
# 打印对象分布
-XX:+PrintTenuringDistribution
# 打印堆数据
-XX:+PrintHeapAtGC
# 打印Reference处理信息
# 强引用/弱引用/软引用/虚引用/finalize 相关的方法
-XX:+PrintReferenceGC
# 打印STW时间
-XX:+PrintGCApplicationStoppedTime

# 可选
# 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint
-XX:+PrintSafepointStatistics
-XX:PrintSafepointStatisticsCount=1

# GC日志输出的文件路径
-Xloggc:/path/to/gc-%t.log
# 开启日志文件分割
-XX:+UseGCLogFileRotation
# 最多分割几个文件，超过之后从头文件开始写
-XX:NumberOfGCLogFiles=14
# 每个文件上限大小，超过就触发分割
-XX:GCLogFileSize=50M
```

#### 处理OOM

```java
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=./java_pid<pid>.hprof
-XX:OnOutOfMemoryError="< cmd args >;< cmd args >"
-XX:+UseGCOverheadLimit
```

### JDK监控和故障处理工具总结

#### JDK命令行工具

1. jps (JVM Process Status）: 类似 UNIX 的 ps 命令。**用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；**
2. jstat（JVM Statistics Monitoring Tool）: **用于收集 HotSpot 虚拟机各方面的运行数据;**
3. jinfo (Configuration Info for Java) : Configuration Info for Java,**显示虚拟机配置信息;**
4. jmap (Memory Map for Java) : 生成堆转储快照;
5. jhat (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。JDK9 移除了 jhat；
6. jstack (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合

#### JDK可视化分析工具

1. **JConsole：Java监视与管理控制台**
2. **VisualVM：多合一故障处理工具**
3. **MAT：内存分析器工具**

### JVM线上问题排查和性能调优案例

#### 一次线上 OOM 问题分析 - 艾小仙 - 2023

现象：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。
分析：使用 JDK 自带的jvisualvm分析 dump 文件(MAT 也能分析)。
建议：对于 SQL 语句，如果监测到没有where条件的全表查询应该默认增加一个合适的limit作为限制，防止这种问题拖垮整个系统
资料：实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022。

#### 生产事故-记一次特殊的 OOM 排查 - 程语有云 - 2023

现象：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。
临时解决办法：紧急回滚至上一稳定版本。
分析：使用 MAT (Memory Analyzer Tool)工具分析 dump 文件。
建议：正常情况下，-Xmn参数（控制 Young 区的大小）总是应当小于-Xmx参数（控制堆内存的最大大小），否则就会触发 OOM 错误。
资料：最重要的 JVM 参数总结 - JavaGuide - 2023

#### 一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022

现象：线上项目刚启动完使用 top 命令查看 RES 占用了超过 1.5G。
分析：整个分析流程用到了较多工作，可以跟着作者思路一步一步来，值得学习借鉴。
建议：远离 Hibernate。
资料：Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）

#### YGC 问题排查，又让我涨姿势了！ - IT 人的职场进阶 - 2021

现象：广告服务在新版本上线后，收到了大量的服务超时告警。
分析：使用 MAT (Memory Analyzer Tool) 工具分析 dump 文件。
建议：学会 YGC（Young GC） 问题的排查思路，掌握 YGC 的相关知识点。

#### 听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021

通过观察 GC 频率和停顿时间，来进行 JVM 内存空间调整，使其达到最合理的状态。调整过程记得小步快跑，避免内存剧烈波动影响线上服务。 这其实是最为简单的一种 JVM 性能调优方式了，可以算是粗调吧。
你们要的线上 GC 问题案例来啦 - 编了个程 - 2021
案例 1：使用 guava cache 的时候，没有设置最大缓存数量和弱引用，导致频繁触发 Young GC
案例 2： 对于一个查询和排序分页的 SQL，同时这个 SQL 需要 join 多张表，在分库分表下，直接调用 SQL 性能很差。于是，查单表，再在内存排序分页，用了一个 List 来保存数据，而有些数据量大，造成了这个现象。
Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团 - 2020
这篇文章共 2w+ 字，详细介绍了 GC 基础，总结了 CMS GC 的一些常见问题分析与解决办法。

#### 给祖传系统做了点 GC 调优，暂停时间降低了 90% - 京东云技术团队 - 2023

这篇文章提到了一个在规则引擎系统中遇到的 GC（垃圾回收）问题，主要表现为系统在启动后发生了一次较长的 Young GC（年轻代垃圾回收）导致性能下降。经过分析，问题的核心在于动态对象年龄判定机制，它导致了过早的对象晋升，引起了长时间的垃圾回收。

